<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>股票投资组合追踪器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- 配置和云端同步 -->
    <script src="config.js"></script>
    <script src="cloud-sync.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Microsoft YaHei', 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            padding: 20px;
            color: #1a202c;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 12px;
            padding: 32px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
            position: relative;
            background: #ffffff;
            color: #1a202c;
            padding: 24px;
            border-radius: 8px;
            border-bottom: 1px solid #e2e8f0;
        }

        .header-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        .nav-link {
            color: #4a5568;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .nav-link:hover {
            background: #f7fafc;
            color: #2d3748;
        }

        .nav-link.active {
            background: #2b6cb0;
            color: white;
            font-weight: 600;
        }

        h1 {
            color: #1a202c;
            font-size: 2.4em;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            letter-spacing: -0.025em;
        }

        .last-update {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
            margin-top: 10px;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }

        .summary-card {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .summary-card h3 {
            color: #666;
            font-size: 0.95em;
            margin-bottom: 12px;
            font-weight: 500;
        }

        .summary-card p {
            font-size: 2em;
            font-weight: bold;
            color: #1e3c72;
        }

        .summary-card.profit p {
            color: #10b981;
        }

        .summary-card.loss p {
            color: #ef4444;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        .add-stock-section {
            background: #667eea;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .add-stock-section h2 {
            color: white;
            margin-bottom: 25px;
            font-size: 1.6em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cash-management-section {
            background: #28a745;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .cash-management-section h2 {
            color: white;
            margin-bottom: 25px;
            font-size: 1.6em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chart-section {
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .chart-section h2 {
            color: #1e3c72;
            margin-bottom: 20px;
            font-size: 1.6em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .input-wrapper {
            display: flex;
            flex-direction: column;
        }

        label {
            color: white;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 1em;
        }

        input {
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            background: rgba(255, 255, 255, 0.95);
            transition: all 0.3s;
        }

        input:focus {
            outline: none;
            background: white;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        button {
            background: #ffffff;
            color: #4a5568;
            border: 1px solid #e2e8f0;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            background: #f7fafc;
            border-color: #cbd5e0;
            color: #2d3748;
        }

        .refresh-btn {
            background: #ffffff;
            color: #374151;
            border: 1px solid #d1d5db;
        }

        .refresh-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .export-btn {
            background: #3b82f6;
            color: white;
            margin-left: 10px;
            border: none;
        }

        .export-btn:hover {
            background: #2563eb;
        }

        .portfolio-table {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            margin-bottom: 30px;
        }

        .table-header {
            background: #1e3c72;
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-header h2 {
            font-size: 1.6em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-actions {
            display: flex;
            gap: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: #f8f9fa;
            color: #1e3c72;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            font-size: 0.95em;
            border-bottom: 2px solid #e9ecef;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid #f1f3f5;
            font-size: 0.95em;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .stock-symbol {
            font-weight: bold;
            color: #1e3c72;
            font-size: 1.1em;
        }

        .positive {
            color: #10b981;
            font-weight: 600;
        }

        .negative {
            color: #ef4444;
            font-weight: 600;
        }

        .neutral {
            color: #6b7280;
            font-weight: 600;
        }

        .action-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .buy-more-btn, .sell-part-btn, .delete-btn {
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .buy-more-btn {
            background: #28a745;
            color: white;
        }

        .buy-more-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .sell-part-btn {
            background: #ffc107;
            color: #212529;
        }

        .sell-part-btn:hover {
            background: #e0a800;
            transform: translateY(-1px);
        }

        .delete-btn {
            background: #dc3545;
            color: white;
        }

        .delete-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #999;
        }

        .empty-state h3 {
            font-size: 1.8em;
            margin-bottom: 15px;
            color: #666;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: white;
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 400px;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            border-left: 5px solid #10b981;
        }

        .toast.error {
            border-left: 5px solid #ef4444;
        }

        .toast.warning {
            border-left: 5px solid #f59e0b;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            padding: 20px 25px;
            background: #ffffff;
            color: #1f2937;
            border-bottom: 1px solid #e5e7eb;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.4em;
        }

        .modal-close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .modal-body {
            padding: 20px 25px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .stock-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .stock-info h4 {
            margin: 0;
            color: #495057;
            font-size: 1.1em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.2s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .input-hint {
            display: block;
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
        }

        .calculated-amount, .calculated-profit {
            padding: 12px;
            background: #e9ecef;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: 600;
        }

        .calculated-profit.positive {
            background: #d4edda;
            color: #155724;
        }

        .calculated-profit.negative {
            background: #f8d7da;
            color: #721c24;
        }

        .modal-footer {
            padding: 20px 25px;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            background: white;
            border-radius: 0 0 15px 15px;
            position: sticky;
            bottom: 0;
            margin-top: auto;
        }

        .modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cancel-btn {
            background: #6c757d;
            color: white;
        }

        .cancel-btn:hover {
            background: #5a6268;
        }

        .confirm-btn {
            background: #28a745;
            color: white;
        }

        .confirm-btn:hover {
            background: #218838;
        }

        .confirm-btn.sell {
            background: #ffc107;
            color: #212529;
        }

        .confirm-btn.sell:hover {
            background: #e0a800;
        }

        .confirm-btn.delete {
            background: #dc3545;
        }

        .confirm-btn.delete:hover {
            background: #c82333;
        }

        .stock-chart-row {
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }

        .stock-chart-container {
            padding: 20px;
            margin: 10px 0;
            width: 100%;
            overflow: hidden;
        }

        .stock-chart-container h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 14px;
            font-weight: 600;
        }

        .stock-chart-container canvas {
            max-width: 100% !important;
            width: 100% !important;
            height: 200px !important;
            border-radius: 6px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: block;
        }

        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 200px;
        }

        .stock-detail-header {
            padding: 15px 20px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background-color 0.2s ease;
        }

        .stock-detail-header:hover {
            background: #dee2e6;
        }

        .detail-toggle-icon {
            font-size: 14px;
            transition: transform 0.2s ease;
            color: #007bff;
            font-weight: bold;
        }

        .detail-toggle-icon.expanded {
            transform: rotate(-90deg);
        }

        .detail-title {
            font-weight: 600;
            color: #495057;
            font-size: 15px;
        }

        .detail-subtitle {
            font-size: 12px;
            color: #6c757d;
            margin-left: auto;
        }

        .stock-detail-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 20px;
            background: #f8f9fa;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 1000px;
            }
        }

        .loading-data {
            color: #6c757d;
            font-style: italic;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .stock-specs h4 {
            margin: 0 0 20px 0;
            color: #495057;
            font-size: 16px;
            font-weight: 600;
            border-bottom: 2px solid #007bff;
            padding-bottom: 8px;
        }

        .specs-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .spec-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .spec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .spec-item:last-child {
            border-bottom: none;
        }

        .spec-label {
            font-size: 13px;
            color: #6c757d;
            font-weight: 500;
        }

        .spec-value {
            font-size: 13px;
            color: #495057;
            font-weight: 600;
            text-align: right;
        }

        @media (max-width: 1200px) {
            .stock-detail-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .specs-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 1366px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .summary-cards {
                grid-template-columns: 1fr 1fr;
            }
            
            table {
                font-size: 0.85em;
            }
            
            th, td {
                padding: 10px 8px;
            }

            .button-group {
                grid-template-columns: 1fr;
            }

            .table-actions {
                flex-direction: column;
            }
        }

        /* Robinhood-style Time Selector */
        .time-selector {
            display: flex;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 2px;
            gap: 2px;
            backdrop-filter: blur(10px);
        }

        .time-selector.dark {
            background: rgba(255, 255, 255, 0.1);
        }

        .time-selector.light {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .time-btn {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 500;
            color: #6b7280;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 36px;
            text-align: center;
        }

        .time-btn:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            color: #374151;
        }

        .time-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
            font-weight: 600;
        }

        .time-selector-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .time-selector-label {
            color: white;
            font-size: 0.9em;
            font-weight: 500;
        }

        .time-selector-label.light {
            color: #333;
        }

        /* 隐藏数字输入框的上下箭头 */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Firefox */
        input[type="number"] {
            -moz-appearance: textfield;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                📊 股票投资组合追踪器
            </h1>
            <div class="header-nav">
                <div class="nav-links">
                    <a href="/" class="nav-link active">📈 投资组合</a>
                    <a href="transactions.html" class="nav-link">📋 交易记录</a>
                </div>
                <div class="last-update">
                    最后更新: <span id="lastUpdate">-</span>
                </div>
            </div>
        </div>
        
        <div class="summary-cards">
            <div class="summary-card">
                <h3>💵 现金余额</h3>
                <p id="cashBalance">$0.00</p>
            </div>
            <div class="summary-card">
                <h3>💎 当前市值</h3>
                <p id="currentValue">$0.00</p>
            </div>
            <div class="summary-card" id="totalReturnCard">
                <h3>📈 浮盈收益</h3>
                <p id="totalReturn">$0.00</p>
            </div>
            <div class="summary-card">
                <h3>📝 持仓数量</h3>
                <p id="stockCount">0</p>
            </div>
            <div class="summary-card">
                <h3>💸 总手续费</h3>
                <p id="totalFees">$0.00</p>
            </div>
            <div class="summary-card">
                <h3>💰 本金</h3>
                <p id="totalInvestment">$0.00</p>
            </div>
        </div>

        <div class="main-content">
            <div class="cash-management-section">
                <h2>💰 资金管理</h2>
                <div class="input-group">
                    <div class="input-wrapper">
                        <label for="cashAmount">金额（美元）</label>
                        <input type="number" id="cashAmount" placeholder="1000.00" step="0.01" required>
                    </div>
                    <div class="input-wrapper">
                        <label for="cashDate">交易日期</label>
                        <input type="date" id="cashDate" required>
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="depositCash()">💵 转入资金</button>
                    <button onclick="withdrawCash()">💸 转出资金</button>
                </div>
                <div style="margin-top: 20px; color: white; font-size: 0.9em;">
                    <p>💡 当前现金余额: $<span id="currentCashDisplay">0.00</span></p>
                </div>
            </div>
            <div class="add-stock-section">
                <h2>➕ 添加新交易</h2>
                <div class="input-group">
                    <div class="input-wrapper">
                        <label for="stockSymbol">股票代码（如：AAPL、MSFT）</label>
                        <input type="text" id="stockSymbol" placeholder="输入美股代码" required>
                    </div>
                    <div class="input-wrapper">
                        <label for="shares">购买股数</label>
                        <input type="number" id="shares" placeholder="10" step="0.01" required>
                    </div>
                    <div class="input-wrapper">
                        <label for="buyPrice">买入价格（每股美元）</label>
                        <input type="number" id="buyPrice" placeholder="150.00" step="0.01" required>
                    </div>
                    <div class="input-wrapper">
                        <label for="initialFee">手续费（每股美元）</label>
                        <input type="number" id="initialFee" placeholder="0.02" step="0.001" min="0" value="0.02">
                    </div>
                    <div class="input-wrapper">
                        <label for="buyDate">购买日期</label>
                        <input type="date" id="buyDate" required>
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="addStock()">📥 添加到组合</button>
                    <button onclick="quickFillDemo()">🎯 快速示例</button>
                </div>
            </div>
            <div class="chart-section">
                <h2>🥧 持仓分布图</h2>
                <div class="chart-container">
                    <canvas id="portfolioChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Portfolio Value Trend Chart Section -->
        <div class="portfolio-table" style="margin-bottom: 30px;">
            <div class="table-header">
                <h2>📈 资产走势图</h2>
                <div class="table-actions" style="display: flex; align-items: center; gap: 15px;">
                    <div class="time-selector-container">
                        <span class="time-selector-label">时间范围:</span>
                        <div class="time-selector dark" id="portfolioTimeSelector">
                            <button class="time-btn active" data-period="1D" onclick="selectTimeRange('1D')">日线</button>
                            <button class="time-btn" data-period="1W" onclick="selectTimeRange('1W')">周线</button>
                            <button class="time-btn" data-period="1M" onclick="selectTimeRange('1M')">月线</button>
                            <button class="time-btn" data-period="3M" onclick="selectTimeRange('3M')">季线</button>
                            <button class="time-btn" data-period="6M" onclick="selectTimeRange('6M')">半年线</button>
                            <button class="time-btn" data-period="YTD" onclick="selectTimeRange('YTD')">今年</button>
                        </div>
                    </div>
                    <button class="refresh-btn" onclick="refreshPortfolioTrend()" id="refreshTrendBtn">
                        🔄 更新走势
                    </button>
                </div>
            </div>
            <div style="padding: 30px; background: white;">
                <div class="chart-container" style="height: 400px;">
                    <canvas id="portfolioTrendChart"></canvas>
                </div>
            </div>
            </div>
        </div>

        <div class="portfolio-table">
            <div class="table-header">
                <h2>📋 我的持仓明细</h2>
                <div class="table-actions">
                    <button class="refresh-btn" onclick="refreshAllPrices()" id="refreshBtn">
                        🔄 刷新所有价格
                    </button>
                </div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th>股票代码</th>
                        <th>公司名称</th>
                        <th>持股数</th>
                        <th>买入价</th>
                        <th>当前价</th>
                        <th>成本</th>
                        <th>市值</th>
                        <th>盈亏($)</th>
                        <th>盈亏(%)</th>
                        <th>仓位占比</th>
                        <th>持有天数</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="portfolioBody">
                    <tr class="empty-state">
                        <td colspan="12">
                            <h3>📭 暂无持仓</h3>
                            <p>使用上方表单添加您的第一支股票</p>
                            <p style="margin-top: 10px; color: #666;">支持美股实时价格自动更新</p>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Trading Modal -->
    <div id="tradingModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">交易操作</h3>
                <span class="modal-close" onclick="closeTradingModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="stock-info">
                    <h4 id="modalStockInfo">股票信息</h4>
                </div>
                <form id="tradingForm">
                    <div class="form-group">
                        <label for="modalShares">股数:</label>
                        <input type="number" id="modalShares" step="0.01" min="0" required>
                        <span class="input-hint" id="sharesHint"></span>
                    </div>
                    <div class="form-group">
                        <label for="modalPrice">价格:</label>
                        <input type="number" id="modalPrice" step="0.01" min="0" required>
                        <span class="input-hint" id="priceHint"></span>
                    </div>
                    <div class="form-group">
                        <label for="modalFee">手续费 (每股):</label>
                        <input type="number" id="modalFee" step="0.001" min="0" value="0.02" placeholder="0.02">
                        <span class="input-hint">通常为 $0.005-$0.01 每股</span>
                    </div>
                    <div class="form-group">
                        <label>预计金额:</label>
                        <div class="calculated-amount" id="calculatedAmount">$0.00</div>
                    </div>
                    <div class="form-group">
                        <label>总手续费:</label>
                        <div class="calculated-fee" id="calculatedFee">$0.00</div>
                    </div>
                    <div class="form-group" id="profitInfo" style="display: none;">
                        <label>预计盈亏:</label>
                        <div class="calculated-profit" id="calculatedProfit">$0.00</div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="modal-btn cancel-btn" onclick="closeTradingModal()">取消</button>
                <button type="button" class="modal-btn confirm-btn" id="confirmTradeBtn" onclick="confirmTrade()">确认</button>
            </div>
        </div>
    </div>

    <div id="toast" class="toast">
        <span id="toastMessage"></span>
    </div>

    <script>
        // Portfolio data
        let portfolio = [];
        let chartInstance = null;
        let portfolioTrendChart = null;
        let lastUpdateTime = null;
        let transactionHistory = []; // Track all buy/sell transactions
        let totalRealizedProfit = 0; // Track total realized profit/loss
        let currentTimeRange = '1D'; // Default to daily view
        let rawHistoricalData = []; // Store raw daily data for aggregation
        let cashBalance = 0; // Current cash balance

        // Finnhub API configuration
        const FINNHUB_API_KEY = 'd2mcdc9r01qq6foq0p40d2mcdc9r01qq6foq0p4g'; // Free tier API key
        
        // Cache to store prices and reduce API calls
        const priceCache = new Map();

        // Base prices for consistent simulation (updated daily)
        const basePrices = new Map();
        let lastPriceUpdateDate = null;
        const CACHE_DURATION = 60000; // Cache for 1 minute


        // Company names mapping
        const companyNames = {
            'AAPL': '苹果公司',
            'MSFT': '微软',
            'GOOGL': '谷歌',
            'GOOG': '谷歌',
            'AMZN': '亚马逊',
            'META': 'Meta',
            'TSLA': '特斯拉',
            'NVDA': '英伟达',
            'TSM': '台积电',
            'BABA': '阿里巴巴',
            'JD': '京东',
            'PDD': '拼多多',
            'NIO': '蔚来',
            'BIDU': '百度',
            'NTES': '网易',
            'TME': '腾讯音乐',
            'BILI': '哔哩哔哩',
            'AMD': 'AMD',
            'INTC': '英特尔',
            'DIS': '迪士尼',
            'NFLX': '奈飞',
            'BA': '波音',
            'V': 'Visa',
            'MA': '万事达',
            'JPM': '摩根大通',
            'BAC': '美国银行',
            'WMT': '沃尔玛',
            'KO': '可口可乐',
            'PEP': '百事可乐',
            'MCD': '麦当劳',
            'SBUX': '星巴克',
            'NKE': '耐克',
            'ADBE': 'Adobe',
            'CRM': 'Salesforce',
            'ORCL': '甲骨文',
            'IBM': 'IBM',
            'CSCO': '思科',
            'QCOM': '高通',
            'TXN': '德州仪器',
            'AVGO': '博通',
            'COST': '好市多',
            'PG': '宝洁',
            'JNJ': '强生',
            'UNH': '联合健康',
            'HD': '家得宝',
            'CVX': '雪佛龙',
            'XOM': '埃克森美孚'
        };

        // Initialize
        window.onload = async function() {
            // ===== 云端同步初始化 =====
            await initCloudSync();
            // ===== 云端同步初始化结束 =====

            // 注意：initCloudSync()已经从云端加载数据到portfolio、cashBalance等变量
            // 所以下面的本地加载代码只在云端没有数据时作为fallback

            // 如果云端没有加载到数据，从本地加载
            if (portfolio.length === 0) {
                const saved = localStorage.getItem('portfolio');
                if (saved) {
                    portfolio = JSON.parse(saved);
                }
            }

            if (cashBalance === 0) {
                const savedCash = localStorage.getItem('cashBalance');
                if (savedCash) {
                    cashBalance = parseFloat(savedCash);
                }
            }

            if (transactionHistory.length === 0) {
                await loadTransactionHistory(); // Load transaction history and realized profit
            }

            // Update cash display after loading
            updateCashDisplay();

            // Update all display data after loading
            updateDisplay();

            // Auto refresh prices on load
            if (portfolio.length > 0) {
                setTimeout(() => refreshAllPrices(), 1000);
            }

            // Set default date for cash transactions to today
            document.getElementById('cashDate').value = new Date().toISOString().split('T')[0];

            // Data is now automatically saved to browser cache
            console.log('Portfolio tracker loaded - all data automatically saved to browser cache');

            initChart();
            initPortfolioTrendChart();
            checkAPIStatus();

            // Initialize portfolio trend chart if we have data
            if (portfolio.length > 0 || transactionHistory.length > 0) {
                setTimeout(() => updatePortfolioTrendChart(), 2000);
            }
        };

        async function checkAPIStatus() {
            const apiStatus = document.getElementById('apiStatus');

            try {
                // 检查API是否运行（使用配置的API地址）
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const response = await fetch(`${apiUrl}/api/health`);
                if (response.ok) {
                    const data = await response.json();
                    apiStatus.textContent = 'API已连接 (本地Python服务)';
                    apiStatus.className = 'api-status connected';
                } else {
                    throw new Error('健康检查失败');
                }
            } catch (error) {
                apiStatus.textContent = 'API未连接 (请启动Python服务)';
                apiStatus.className = 'api-status error';
                console.warn('本地API服务未运行:', error.message);
            }
        }

        function savePortfolio() {
            localStorage.setItem('portfolio', JSON.stringify(portfolio));
            // 触发云端同步
            if (typeof syncToCloud === 'function') {
                syncToCloud().catch(err => console.error('云端同步失败:', err));
            }
        }

        function saveCashBalance() {
            localStorage.setItem('cashBalance', cashBalance.toString());
            // 触发云端同步
            if (typeof syncToCloud === 'function') {
                syncToCloud().catch(err => console.error('云端同步失败:', err));
            }
        }

        // Cash management functions
        function depositCash() {
            const amountInput = document.getElementById('cashAmount');
            const dateInput = document.getElementById('cashDate');
            const amount = parseFloat(amountInput.value);
            const cashDate = dateInput.value;

            if (!amount || amount <= 0) {
                showToast('请输入有效的转入金额', 'error');
                return;
            }

            if (!cashDate) {
                showToast('请选择交易日期', 'error');
                return;
            }

            cashBalance += amount;
            saveCashBalance();

            // Record transaction first
            const transaction = {
                id: Date.now(),
                type: 'cash_deposit',
                amount: amount,
                date: cashDate + 'T12:00:00.000Z',
                timestamp: new Date().toISOString(),
                description: `资金转入 $${amount.toFixed(2)}`
            };
            transactionHistory.push(transaction);
            saveTransactionHistory();

            // Then update display
            updateDisplay();

            amountInput.value = '';
            dateInput.value = '';
            showToast(`成功转入 $${amount.toFixed(2)}`, 'success');
        }

        function withdrawCash() {
            const amountInput = document.getElementById('cashAmount');
            const dateInput = document.getElementById('cashDate');
            const amount = parseFloat(amountInput.value);
            const cashDate = dateInput.value;

            if (!amount || amount <= 0) {
                showToast('请输入有效的转出金额', 'error');
                return;
            }

            if (!cashDate) {
                showToast('请选择交易日期', 'error');
                return;
            }

            if (amount > cashBalance) {
                showToast('现金余额不足', 'error');
                return;
            }

            cashBalance -= amount;
            saveCashBalance();

            // Record transaction first
            const transaction = {
                id: Date.now(),
                type: 'cash_withdrawal',
                amount: -amount,
                date: cashDate + 'T12:00:00.000Z',
                timestamp: new Date().toISOString(),
                description: `资金转出 $${amount.toFixed(2)}`
            };
            transactionHistory.push(transaction);
            saveTransactionHistory();

            // Then update display
            updateDisplay();

            amountInput.value = '';
            dateInput.value = '';
            showToast(`成功转出 $${amount.toFixed(2)}`, 'success');
        }

        function saveTransactionHistory() {
            localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));
            localStorage.setItem('totalRealizedProfit', totalRealizedProfit.toString());

            // Also save to IndexedDB for better persistence
            saveToIndexedDB();

            // 触发云端同步
            if (typeof syncToCloud === 'function') {
                syncToCloud().catch(err => console.error('云端同步失败:', err));
            }
        }

        // Save to IndexedDB for better persistence
        async function saveToIndexedDB() {
            const data = {
                transactions: transactionHistory,
                totalRealizedProfit: totalRealizedProfit,
                lastUpdated: new Date().toISOString()
            };

            try {
                const request = indexedDB.open('PortfolioTracker', 1);
                request.onupgradeneeded = function(event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('transactions')) {
                        db.createObjectStore('transactions', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('data')) {
                        db.createObjectStore('data');
                    }
                };
                request.onsuccess = function(event) {
                    const db = event.target.result;
                    const transaction = db.transaction(['data'], 'readwrite');
                    const store = transaction.objectStore('data');
                    store.put(data, 'transactionData');
                };
            } catch (error) {
                console.error('Error saving to IndexedDB:', error);
            }
        }

        // Load from IndexedDB
        async function loadFromIndexedDB() {
            return new Promise((resolve) => {
                try {
                    const request = indexedDB.open('PortfolioTracker', 1);
                    request.onsuccess = function(event) {
                        const db = event.target.result;
                        if (db.objectStoreNames.contains('data')) {
                            const transaction = db.transaction(['data'], 'readonly');
                            const store = transaction.objectStore('data');
                            const getRequest = store.get('transactionData');
                            getRequest.onsuccess = function() {
                                resolve(getRequest.result || null);
                            };
                            getRequest.onerror = function() {
                                resolve(null);
                            };
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = function() {
                        resolve(null);
                    };
                } catch (error) {
                    resolve(null);
                }
            });
        }

        // Show notification
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 10000;
                font-family: inherit;
                max-width: 300px;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.3s';
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 3000);
        }

        async function loadTransactionHistory() {
            // First try to load from IndexedDB
            const indexedData = await loadFromIndexedDB();
            if (indexedData && indexedData.transactions) {
                transactionHistory = indexedData.transactions;
                totalRealizedProfit = indexedData.totalRealizedProfit || 0;
                console.log('Loaded transactions from IndexedDB:', indexedData);
                return;
            }

            // Fallback to localStorage
            const saved = localStorage.getItem('transactionHistory');
            if (saved) {
                transactionHistory = JSON.parse(saved);
            }

            const savedProfit = localStorage.getItem('totalRealizedProfit');
            if (savedProfit) {
                totalRealizedProfit = parseFloat(savedProfit);
            }

            // If we have localStorage data, save it to IndexedDB for future use
            if (transactionHistory.length > 0) {
                saveToIndexedDB();
            }
        }

        // Test local Python API connection
        async function testAPI(symbol = 'AAPL') {
            console.log('Testing local Python API with symbol:', symbol);
            showToast(`正在测试本地Python API...`, 'info');

            try {
                console.log(`🔄 Testing Local Python API...`);

                const startTime = Date.now();
                const price = await fetchFromLocalAPI(symbol);
                const duration = Date.now() - startTime;

                if (price && price > 0) {
                    console.log(`✅ 本地API - Success: $${price} (${duration}ms)`);
                    showToast(`✅ 本地API - ${symbol}价格: $${price.toFixed(2)} (${duration}ms)`, 'success');
                    return { api: '本地Python API', success: true, price, duration };
                } else {
                    console.log(`❌ 本地API - Invalid price: ${price}`);
                    showToast(`❌ 本地API - 无效价格`, 'error');
                    return { api: '本地Python API', success: false, error: 'Invalid price' };
                }
            } catch (error) {
                console.error(`❌ 本地API - Error:`, error.message);
                showToast(`❌ 本地API - 失败: ${error.message} (请确保Python服务正在运行)`, 'error');
                return { api: '本地Python API', success: false, error: error.message };
            }
        }

        // Make testAPI available globally for console testing
        window.testAPI = testAPI;

        // Test functions for debugging
        window.testYahoo = fetchFromYahoo;

        // Quick Yahoo Finance test function
        window.testYahooAPI = async function(symbol = 'AAPL') {
            console.log(`🧪 Testing Yahoo Finance API with symbol: ${symbol}`);

            try {
                console.log(`Testing Yahoo Finance...`);
                const price = await fetchFromYahoo(symbol);
                console.log(`✅ Yahoo Finance: $${price}`);
                return price;
            } catch (error) {
                console.error(`❌ Yahoo Finance: ${error.message}`);
                return null;
            }
        };

        // Test historical data APIs
        window.testHistoricalAPIs = async function(symbol = 'AAPL') {
            console.log(`📊 Testing historical data APIs for ${symbol}...`);
            showToast(`开始测试 ${symbol} 的历史数据API...`, 'info');

            const results = [];

            // Test Alpha Vantage Historical Data
            try {
                console.log('🔄 Testing Alpha Vantage Historical...');
                const alphaUrl = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&apikey=demo&outputsize=compact`;
                const response = await fetch(alphaUrl);
                const data = await response.json();

                if (data['Time Series (Daily)']) {
                    const dates = Object.keys(data['Time Series (Daily)']).slice(0, 5);
                    console.log(`✅ Alpha Vantage: 获取到 ${dates.length} 天数据`);
                    console.log('最近5天:', dates.map(date => ({
                        date,
                        close: data['Time Series (Daily)'][date]['4. close']
                    })));
                    results.push({ api: 'Alpha Vantage', success: true, days: dates.length });
                } else {
                    console.log('❌ Alpha Vantage: 无效响应', data);
                    results.push({ api: 'Alpha Vantage', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('❌ Alpha Vantage Historical:', error);
                results.push({ api: 'Alpha Vantage', success: false, error: error.message });
            }

            // Test Finnhub Historical Data
            try {
                console.log('🔄 Testing Finnhub Historical...');
                const endDate = Math.floor(Date.now() / 1000);
                const startDate = endDate - (30 * 24 * 60 * 60); // 30 days ago
                const finnhubUrl = `https://finnhub.io/api/v1/stock/candle?symbol=${symbol}&resolution=D&from=${startDate}&to=${endDate}&token=d2mcdc9r01qq6foq0p40d2mcdc9r01qq6foq0p4g`;

                const response = await fetch(finnhubUrl);
                const data = await response.json();

                if (data.s === 'ok' && data.c && data.c.length > 0) {
                    console.log(`✅ Finnhub: 获取到 ${data.c.length} 天数据`);
                    console.log('最近5天收盘价:', data.c.slice(-5));
                    results.push({ api: 'Finnhub', success: true, days: data.c.length });
                } else {
                    console.log('❌ Finnhub: 无效响应', data);
                    results.push({ api: 'Finnhub', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('❌ Finnhub Historical:', error);
                results.push({ api: 'Finnhub', success: false, error: error.message });
            }

            // Test Yahoo Finance Historical
            try {
                console.log('🔄 Testing Yahoo Historical...');
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - (30 * 24 * 60 * 60);
                const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${startTime}&period2=${endTime}&interval=1d`;

                const response = await fetch(yahooUrl);
                const data = await response.json();

                if (data.chart && data.chart.result && data.chart.result[0] && data.chart.result[0].indicators) {
                    const quotes = data.chart.result[0].indicators.quote[0];
                    const closes = quotes.close.filter(c => c !== null);
                    console.log(`✅ Yahoo Finance: 获取到 ${closes.length} 天数据`);
                    console.log('最近5天收盘价:', closes.slice(-5));
                    results.push({ api: 'Yahoo Finance', success: true, days: closes.length });
                } else {
                    console.log('❌ Yahoo Finance: 无效响应', data);
                    results.push({ api: 'Yahoo Finance', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('❌ Yahoo Finance Historical:', error);
                results.push({ api: 'Yahoo Finance', success: false, error: error.message });
            }

            // Test Financial Modeling Prep Historical
            try {
                console.log('🔄 Testing FMP Historical...');
                const fmpUrl = `https://financialmodelingprep.com/api/v3/historical-price-full/${symbol}?timeseries=30&apikey=demo`;

                const response = await fetch(fmpUrl);
                const data = await response.json();

                if (data.historical && data.historical.length > 0) {
                    console.log(`✅ FMP: 获取到 ${data.historical.length} 天数据`);
                    console.log('最近5天:', data.historical.slice(0, 5).map(d => ({ date: d.date, close: d.close })));
                    results.push({ api: 'Financial Modeling Prep', success: true, days: data.historical.length });
                } else {
                    console.log('❌ FMP: 无效响应', data);
                    results.push({ api: 'Financial Modeling Prep', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('❌ FMP Historical:', error);
                results.push({ api: 'Financial Modeling Prep', success: false, error: error.message });
            }

            // Test Twelve Data Historical
            try {
                console.log('🔄 Testing Twelve Data Historical...');
                const twelveUrl = `https://api.twelvedata.com/time_series?symbol=${symbol}&interval=1day&outputsize=30&apikey=demo`;

                const response = await fetch(twelveUrl);
                const data = await response.json();

                if (data.values && data.values.length > 0) {
                    console.log(`✅ Twelve Data: 获取到 ${data.values.length} 天数据`);
                    console.log('最近5天:', data.values.slice(0, 5).map(d => ({ date: d.datetime, close: d.close })));
                    results.push({ api: 'Twelve Data', success: true, days: data.values.length });
                } else {
                    console.log('❌ Twelve Data: 无效响应', data);
                    results.push({ api: 'Twelve Data', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('❌ Twelve Data Historical:', error);
                results.push({ api: 'Twelve Data', success: false, error: error.message });
            }

            // Test IEX Cloud Historical (sandbox)
            try {
                console.log('🔄 Testing IEX Cloud Historical...');
                const iexUrl = `https://cloud.iexapis.com/stable/stock/${symbol}/chart/1m?token=pk_test_free`;

                const response = await fetch(iexUrl);
                const data = await response.json();

                if (Array.isArray(data) && data.length > 0) {
                    console.log(`✅ IEX Cloud: 获取到 ${data.length} 天数据`);
                    console.log('最近5天:', data.slice(-5).map(d => ({ date: d.date, close: d.close })));
                    results.push({ api: 'IEX Cloud', success: true, days: data.length });
                } else {
                    console.log('❌ IEX Cloud: 无效响应', data);
                    results.push({ api: 'IEX Cloud', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('❌ IEX Cloud Historical:', error);
                results.push({ api: 'IEX Cloud', success: false, error: error.message });
            }

            console.log('\n📊 历史数据API测试结果:', results);

            const successCount = results.filter(r => r.success).length;
            showToast(`历史数据测试完成！${successCount}/${results.length} 个API可用`, successCount > 0 ? 'success' : 'warning');

            return results;
        };

        // Fetch real 30-day historical data from local API
        window.fetchReal30DayHistory = async function(symbol) {
            console.log(`📈 获取 ${symbol} 真实30天历史数据...`);
            showToast(`正在从API获取 ${symbol} 的真实历史数据...`, 'info');

            try {
                console.log('🔄 尝试Python API...');
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const url = `${apiUrl}/api/history/${symbol}?period=1M`;

                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    const historicalData = data.data;

                    console.log(`✅ 本地API: 获取到 ${historicalData.length} 天真实数据`);
                    console.log('数据示例:', historicalData.slice(0, 3));
                    showToast(`✅ 获取到 ${historicalData.length} 天 ${symbol} 真实历史数据`, 'success');
                    return historicalData;
                } else {
                    throw new Error(data.error || '本地API返回无效数据');
                }
            } catch (error) {
                console.error('❌ 本地API 失败:', error);
                console.warn('⚠️ 无法获取真实历史数据，建议使用模拟数据');
                showToast(`⚠️ 无法获取 ${symbol} 真实历史数据: ${error.message}`, 'warning');
                return null;
            }
        };

        // Toggle stock details visibility
        function toggleStockDetails(stockId) {
            const container = document.getElementById(`details-${stockId}`);
            const icon = document.getElementById(`toggle-${stockId}`);

            if (container.style.display === 'none') {
                container.style.display = 'grid';
                icon.textContent = '▲';
                icon.classList.add('expanded');

                // Load real stock data when expanded
                loadStockDetails(stockId);
            } else {
                container.style.display = 'none';
                icon.textContent = '▼';
                icon.classList.remove('expanded');
            }
        }

        // Load and populate real stock details
        async function loadStockDetails(stockId) {
            const stock = portfolio.find(s => s.id === stockId);
            if (!stock) return;

            const specsContainer = document.getElementById(`specs-${stockId}`);
            if (!specsContainer) return;

            try {
                const details = await fetchStockDetails(stock.symbol);

                if (details) {
                    // Update all spec values with real data
                    const specItems = specsContainer.querySelectorAll('.spec-item');

                    // Map data to display fields
                    const dataMap = [
                        details.previousClose?.toFixed(2) || 'N/A',
                        details.open?.toFixed(2) || 'N/A',
                        `${details.low?.toFixed(2) || 'N/A'} - ${details.high?.toFixed(2) || 'N/A'}`,
                        `${details.week52Low?.toFixed(2) || 'N/A'} - ${details.week52High?.toFixed(2) || 'N/A'}`,
                        details.volume ? details.volume.toLocaleString('zh-CN') : 'N/A',
                        details.marketCap ? (details.marketCap / 1000).toFixed(3) + 'T' : 'N/A',
                        details.beta?.toFixed(2) || 'N/A',
                        details.peRatio?.toFixed(2) || 'N/A',
                        details.eps?.toFixed(2) || 'N/A',
                        details.currency || 'USD'
                    ];

                    specItems.forEach((item, index) => {
                        const valueSpan = item.querySelector('.spec-value');
                        if (valueSpan && dataMap[index]) {
                            valueSpan.textContent = dataMap[index];
                            valueSpan.classList.remove('loading-data');
                        }
                    });

                    showToast(`${stock.symbol} 详细信息已更新`, 'success');
                } else {
                    showToast(`无法获取 ${stock.symbol} 的详细信息`, 'error');
                }
            } catch (error) {
                console.error(`Error loading details for ${stock.symbol}:`, error);
                showToast(`获取 ${stock.symbol} 详细信息失败`, 'error');
            }
        }

        // Trading Modal Variables
        let currentTradeStock = null;
        let currentTradeType = null;

        // Open trading modal
        function openTradingModal(stockId, tradeType) {
            const stock = portfolio.find(s => s.id === stockId);
            if (!stock) return;

            currentTradeStock = stock;
            currentTradeType = tradeType;

            const modal = document.getElementById('tradingModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalStockInfo = document.getElementById('modalStockInfo');
            const sharesHint = document.getElementById('sharesHint');
            const priceHint = document.getElementById('priceHint');
            const profitInfo = document.getElementById('profitInfo');
            const confirmBtn = document.getElementById('confirmTradeBtn');

            // Configure modal based on trade type
            if (tradeType === 'buy') {
                modalTitle.textContent = '📈 加仓操作';
                sharesHint.textContent = '输入要加仓的股数';
                priceHint.textContent = `建议价格: $${stock.currentPrice.toFixed(2)}`;
                profitInfo.style.display = 'none';
                confirmBtn.textContent = '确认加仓';
                confirmBtn.className = 'modal-btn confirm-btn';
            } else if (tradeType === 'sell') {
                modalTitle.textContent = '📉 减仓操作';
                sharesHint.textContent = `最多可卖: ${stock.shares.toFixed(2)} 股`;
                priceHint.textContent = `建议价格: $${stock.currentPrice.toFixed(2)}`;
                profitInfo.style.display = 'block';
                confirmBtn.textContent = '确认减仓';
                confirmBtn.className = 'modal-btn confirm-btn sell';
            } else if (tradeType === 'delete') {
                modalTitle.textContent = '🗑️ 清仓操作';
                sharesHint.textContent = `将卖出全部 ${stock.shares.toFixed(2)} 股`;
                priceHint.textContent = `建议价格: $${stock.currentPrice.toFixed(2)}`;
                profitInfo.style.display = 'block';
                confirmBtn.textContent = '确认清仓';
                confirmBtn.className = 'modal-btn confirm-btn delete';

                // Pre-fill shares for delete operation
                document.getElementById('modalShares').value = stock.shares.toFixed(2);
                document.getElementById('modalShares').readOnly = true;
            }

            modalStockInfo.textContent = `${stock.symbol} - 当前持股: ${stock.shares.toFixed(2)} 股 | 成本价: $${stock.buyPrice.toFixed(2)} | 当前价: $${stock.currentPrice.toFixed(2)}`;

            // Pre-fill current price
            document.getElementById('modalPrice').value = stock.currentPrice.toFixed(2);

            // Add input listeners for real-time calculation
            setupModalCalculations();

            modal.style.display = 'block';
        }

        // Close trading modal
        function closeTradingModal() {
            const modal = document.getElementById('tradingModal');
            modal.style.display = 'none';

            // Reset form
            document.getElementById('tradingForm').reset();
            document.getElementById('modalShares').readOnly = false;
            currentTradeStock = null;
            currentTradeType = null;
        }

        // Setup real-time calculations in modal
        function setupModalCalculations() {
            const sharesInput = document.getElementById('modalShares');
            const priceInput = document.getElementById('modalPrice');
            const feeInput = document.getElementById('modalFee');

            function calculateAmounts() {
                const shares = parseFloat(sharesInput.value) || 0;
                const price = parseFloat(priceInput.value) || 0;
                const feePerShare = parseFloat(feeInput.value) || 0;
                const totalAmount = shares * price;
                const totalFee = shares * feePerShare;

                document.getElementById('calculatedAmount').textContent = `$${totalAmount.toFixed(2)}`;
                document.getElementById('calculatedFee').textContent = `$${totalFee.toFixed(2)}`;

                // Calculate profit for sell operations
                if (currentTradeType === 'sell' || currentTradeType === 'delete') {
                    // Include fees in profit calculation
                    const profit = (price - currentTradeStock.buyPrice) * shares - totalFee;
                    const profitElement = document.getElementById('calculatedProfit');
                    profitElement.textContent = `${profit >= 0 ? '+' : ''}$${profit.toFixed(2)}`;
                    profitElement.className = `calculated-profit ${profit >= 0 ? 'positive' : 'negative'}`;
                }
            }

            sharesInput.addEventListener('input', calculateAmounts);
            priceInput.addEventListener('input', calculateAmounts);
            feeInput.addEventListener('input', calculateAmounts);

            // Initial calculation
            calculateAmounts();
        }

        // Confirm trade operation
        function confirmTrade() {
            const shares = parseFloat(document.getElementById('modalShares').value);
            const price = parseFloat(document.getElementById('modalPrice').value);
            const feePerShare = parseFloat(document.getElementById('modalFee').value) || 0;

            if (!shares || shares <= 0 || !price || price <= 0) {
                showToast('请输入有效的股数和价格', 'error');
                return;
            }

            if (currentTradeType === 'buy') {
                executeBuyMore(currentTradeStock.id, shares, price, feePerShare);
            } else if (currentTradeType === 'sell') {
                if (shares >= currentTradeStock.shares) {
                    showToast('减仓股数不能大于等于持有股数，请使用清仓功能', 'error');
                    return;
                }
                executeSellPart(currentTradeStock.id, shares, price, feePerShare);
            } else if (currentTradeType === 'delete') {
                executeDelete(currentTradeStock.id, price, feePerShare);
            }

            closeTradingModal();
        }

        // Handle individual stock chart time range change
        function onStockTimeRangeChange(stockId, period) {
            console.log(`📊 切换股票 ${stockId} 图表时间周期: ${period}`);

            // Update button states
            const selector = document.getElementById(`stockTimeSelector-${stockId}`);
            if (selector) {
                const buttons = selector.querySelectorAll('.time-btn');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.period === period) {
                        btn.classList.add('active');
                    }
                });
            }

            const stock = portfolio.find(s => s.id == stockId);
            if (stock) {
                renderStockChart(stock, period);
                showToast(`${stock.symbol} 切换到${getTimeRangeDisplayName(period)}视图`, 'success');
            }
        }

        // Make functions globally available
        window.toggleStockDetails = toggleStockDetails;
        window.buyMoreStock = (id) => openTradingModal(id, 'buy');
        window.sellPartStock = (id) => openTradingModal(id, 'sell');
        window.deleteStock = (id) => openTradingModal(id, 'delete');
        window.openTradingModal = openTradingModal;
        window.closeTradingModal = closeTradingModal;
        window.confirmTrade = confirmTrade;
        window.onStockTimeRangeChange = onStockTimeRangeChange;
        window.selectTimeRange = selectTimeRange;

        // Financial Data API (Free tier, CORS enabled)
        async function fetchFromFinancialData(symbol) {
            // Using a free API with CORS support
            const url = `https://financialmodelingprep.com/api/v3/quote-short/${symbol}?apikey=demo`;

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Financial Data API HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data || !Array.isArray(data) || data.length === 0) {
                throw new Error('Invalid Financial Data API response');
            }

            const price = data[0].price;

            if (!price || price <= 0) {
                throw new Error('No valid price from Financial Data API');
            }

            return price;
        }


        // Python API (使用yfinance)
        async function fetchFromLocalAPI(symbol) {
            try {
                // 调用Python API服务
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const url = `${apiUrl}/api/price/${symbol}`;

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`本地API HTTP ${response.status}`);
                }

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || '本地API返回错误');
                }

                const price = data.price;

                if (!price || price <= 0) {
                    throw new Error('本地API返回无效价格');
                }

                return price;
            } catch (error) {
                console.error('本地API调用失败:', error);
                throw error;
            }
        }

        // 为了保持兼容性，保留fetchFromYahoo名称但使用本地API
        async function fetchFromYahoo(symbol) {
            return await fetchFromLocalAPI(symbol);
        }




        // Fetch comprehensive stock data using Finnhub
        async function fetchStockDetails(symbol) {

            try {
                // Fetch multiple endpoints for comprehensive data
                const [quoteResponse, profileResponse, metricsResponse] = await Promise.all([
                    fetch(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`),
                    fetch(`https://finnhub.io/api/v1/stock/profile2?symbol=${symbol}&token=${FINNHUB_API_KEY}`),
                    fetch(`https://finnhub.io/api/v1/stock/metric?symbol=${symbol}&metric=all&token=${FINNHUB_API_KEY}`)
                ]);

                const [quote, profile, metrics] = await Promise.all([
                    quoteResponse.json(),
                    profileResponse.json(),
                    metricsResponse.json()
                ]);

                return {
                    // Basic price data
                    currentPrice: quote.c || 0,
                    previousClose: quote.pc || 0,
                    open: quote.o || 0,
                    high: quote.h || 0,
                    low: quote.l || 0,

                    // 52-week data
                    week52High: metrics.metric?.['52WeekHigh'] || 0,
                    week52Low: metrics.metric?.['52WeekLow'] || 0,

                    // Market cap and financial metrics
                    marketCap: profile.marketCapitalization || 0,
                    peRatio: metrics.metric?.peBasicExclExtraTTM || 0,
                    eps: metrics.metric?.epsBasicExclExtraAnnual || 0,
                    beta: metrics.metric?.beta || 0,

                    // Volume data
                    volume: quote.t || 0, // Last trading timestamp as volume placeholder

                    // Company info
                    name: profile.name || symbol,
                    exchange: profile.exchange || 'NASDAQ',
                    currency: profile.currency || 'USD'
                };
            } catch (error) {
                console.error(`Error fetching stock details for ${symbol}:`, error);
                return null;
            }
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }


        // Fetch real stock price using Yahoo Finance API
        async function fetchStockPrice(symbol) {
            // Validate symbol
            if (!symbol || symbol === 'undefined' || symbol.trim() === '') {
                console.error('Invalid symbol for fetchStockPrice:', symbol);
                return null;
            }

            // Check cache first (increased cache duration for session consistency)
            const cached = priceCache.get(symbol);
            const SESSION_CACHE_DURATION = 300000; // 5 minutes for consistent session experience
            if (cached && Date.now() - cached.timestamp < SESSION_CACHE_DURATION) {
                console.log(`Using cached price for ${symbol}: $${cached.price.toFixed(2)}`);
                return cached.price;
            }

            // Try Yahoo Finance API (most reliable free option)
            try {
                console.log(`🔄 Fetching ${symbol} price from Yahoo Finance...`);
                showToast(`🔄 正在从 Yahoo Finance 获取 ${symbol} 价格...`, 'info');

                const startTime = Date.now();
                const price = await fetchFromYahoo(symbol);
                const duration = Date.now() - startTime;

                if (price && price > 0) {
                    // Cache the price
                    priceCache.set(symbol, {
                        price: price,
                        timestamp: Date.now()
                    });

                    console.log(`✅ Yahoo Finance - Fetched price for ${symbol}: $${price} (${duration}ms)`);
                    showToast(`✅ ${symbol}: $${price.toFixed(2)} (Yahoo Finance)`, 'success');
                    return price;
                } else {
                    console.warn(`⚠️ Yahoo Finance returned invalid price: ${price}`);
                    showToast(`⚠️ Yahoo Finance 返回无效价格`, 'warning');
                }
            } catch (error) {
                console.error(`❌ Yahoo Finance failed for ${symbol}:`, error);
                showToast(`❌ Yahoo Finance 获取失败: ${error.message}`, 'error');
            }

            // If Yahoo Finance fails, use cached price or demo price
            console.error(`Yahoo Finance failed for ${symbol}, using fallback`);
            if (cached) {
                showToast(`使用缓存价格 ${symbol}`, 'warning');
                return cached.price;
            }

            // Fallback to demo prices if Yahoo Finance fails
            showToast(`使用模拟价格 ${symbol}`, 'info');
            return generateSimulatedPrice(symbol);
        }

        // Generate 30-day historical prices for a stock symbol
        function generate30DayHistory(symbol, endPrice = null) {
            const stockBasePrices = {
                'AAPL': 234,      // Apple
                'MSFT': 420,      // Microsoft
                'GOOGL': 155,     // Alphabet
                'AMZN': 178,      // Amazon
                'META': 510,      // Meta
                'TSLA': 240,      // Tesla
                'NVDA': 880,      // NVIDIA
                'TSM': 165,       // Taiwan Semi
                'BABA': 85,       // Alibaba
                'JD': 40,         // JD.com
                'PDD': 138,       // PDD
                'NIO': 5,         // NIO
                'BIDU': 105,      // Baidu
                'NTES': 95,       // NetEase
                'TME': 8,         // Tencent Music
                'BILI': 16        // Bilibili
            };

            // Get base price for this symbol
            const basePrice = endPrice || stockBasePrices[symbol] || (50 + Math.random() * 200);
            const history = [];

            // Generate 30 trading days of historical data
            let currentPrice = basePrice;
            const today = new Date();

            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);

                // Skip weekends (Saturday = 6, Sunday = 0)
                if (date.getDay() === 0 || date.getDay() === 6) {
                    continue;
                }

                // Generate realistic daily price movement (-3% to +3%)
                const dailyChange = (Math.random() - 0.5) * 0.06; // -3% to +3%
                currentPrice = currentPrice * (1 + dailyChange);

                // Add some market trend (slight upward bias)
                const trendFactor = 1 + (Math.random() * 0.002 - 0.001); // Very small trend
                currentPrice *= trendFactor;

                history.push({
                    date: date.toISOString().split('T')[0],
                    close: parseFloat(currentPrice.toFixed(2)),
                    volume: Math.floor(Math.random() * 10000000) + 1000000 // Random volume
                });
            }

            return history;
        }

        // Generate realistic simulated prices with consistent daily updates
        function generateSimulatedPrice(symbol) {
            const today = new Date().toDateString();

            // Check if we need to update base prices for a new day
            if (lastPriceUpdateDate !== today) {
                updateBasePrices();
                lastPriceUpdateDate = today;
            }

            // Get base price for this symbol
            let basePrice = basePrices.get(symbol);
            if (!basePrice) {
                // Initialize base price if it doesn't exist
                const stockBasePrices = {
                    'AAPL': 234,      // Apple
                    'MSFT': 420,      // Microsoft
                    'GOOGL': 155,     // Alphabet
                    'AMZN': 178,      // Amazon
                    'META': 510,      // Meta
                    'TSLA': 240,      // Tesla
                    'NVDA': 880,      // NVIDIA
                    'TSM': 165,       // Taiwan Semi
                    'BABA': 85,       // Alibaba
                    'JD': 40,         // JD.com
                    'PDD': 138,       // PDD
                    'NIO': 5,         // NIO
                    'BIDU': 105,      // Baidu
                    'NTES': 95,       // NetEase
                    'TME': 8,         // Tencent Music
                    'BILI': 16        // Bilibili
                };

                basePrice = stockBasePrices[symbol] || (50 + Math.random() * 200);
                basePrices.set(symbol, basePrice);
            }

            // Add small intraday volatility (±0.5%)
            const intradayVariation = 0.005; // 0.5% max variation
            const variation = (Math.random() - 0.5) * 2 * intradayVariation;
            const currentPrice = basePrice * (1 + variation);

            // Cache the simulated price for session consistency
            priceCache.set(symbol, {
                price: currentPrice,
                timestamp: Date.now()
            });

            showToast(`使用模拟价格 ${symbol}: $${currentPrice.toFixed(2)}`, 'warning');

            return Math.max(currentPrice, 1); // Ensure positive price
        }

        // Update base prices with realistic daily movements
        function updateBasePrices() {
            console.log('更新每日基础价格...');

            for (const [symbol, price] of basePrices.entries()) {
                // Generate realistic daily change (±3% for most stocks)
                const volatility = getSymbolVolatility(symbol);
                const dailyChange = (Math.random() - 0.5) * 2 * volatility;
                const newPrice = price * (1 + dailyChange);

                basePrices.set(symbol, Math.max(newPrice, 1));
                console.log(`${symbol}: $${price.toFixed(2)} → $${newPrice.toFixed(2)} (${(dailyChange * 100).toFixed(2)}%)`);
            }
        }

        // Get volatility for different symbols
        function getSymbolVolatility(symbol) {
            const symbolVolatility = {
                'AAPL': 0.02,    // Apple - 2% daily volatility
                'MSFT': 0.018,   // Microsoft
                'GOOGL': 0.025,  // Alphabet
                'AMZN': 0.03,    // Amazon
                'META': 0.035,   // Meta
                'TSLA': 0.05,    // Tesla - high volatility
                'NVDA': 0.04,    // NVIDIA
                'TSM': 0.03,     // Taiwan Semi
                'BABA': 0.04,    // Alibaba
                'JD': 0.045,     // JD.com
                'PDD': 0.05,     // PDD
                'NIO': 0.06,     // NIO - very high volatility
                'BIDU': 0.04,    // Baidu
                'NTES': 0.03,    // NetEase
                'TME': 0.045,    // Tencent Music
                'BILI': 0.055    // Bilibili
            };

            return symbolVolatility[symbol] || 0.03; // Default 3% volatility
        }

        // Batch fetch prices with delay to respect API limits
        async function fetchMultiplePrices(symbols) {
            const prices = {};
            const delay = 12000; // 12 seconds between calls (Alpha Vantage free tier: 5 calls/minute)
            
            for (let i = 0; i < symbols.length; i++) {
                const symbol = symbols[i];
                try {
                    prices[symbol] = await fetchStockPrice(symbol);
                    
                    // Show progress
                    if (symbols.length > 1) {
                        showToast(`更新进度: ${i + 1}/${symbols.length} - ${symbol}`, 'success');
                    }
                    
                    // Wait between API calls to respect rate limit (except for last one)
                    if (i < symbols.length - 1 && symbols.length > 5) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                } catch (error) {
                    console.error(`Failed to fetch ${symbol}:`, error);
                    prices[symbol] = null;
                }
            }
            
            return prices;
        }

        // Fetch historical price data for individual stock charts
        async function fetchHistoricalData(symbol, period = '1M') {
            // Validate symbol
            if (!symbol || symbol === 'undefined' || symbol.trim() === '') {
                console.error('Invalid symbol for fetchHistoricalData:', symbol);
                return [];
            }

            try {
                console.log(`🔄 获取 ${symbol} 历史数据，周期: ${period}`);

                // 优先使用本地API (支持period参数)
                try {
                    const historicalData = await fetchHistoricalFromLocalAPIByPeriod(symbol, period);
                    if (historicalData && historicalData.length > 0) {
                        console.log(`✅ ${symbol} 本地API获取成功，${historicalData.length}个数据点`);
                        return historicalData.map(item => ({
                            date: item.date,
                            price: item.close
                        }));
                    }
                } catch (localError) {
                    console.warn(`本地API获取失败，尝试备用方案: ${localError}`);
                }

                // 备用方案：使用Alpha Vantage API
                const endDate = new Date();
                const startDate = new Date();

                switch (period) {
                    case '1D':
                        startDate.setDate(endDate.getDate() - 30);
                        break;
                    case '1W':
                        startDate.setDate(endDate.getDate() - 7);
                        break;
                    case '1M':
                        startDate.setDate(endDate.getDate() - 30);
                        break;
                    case '3M':
                        startDate.setDate(endDate.getDate() - 90);
                        break;
                    case '6M':
                        startDate.setDate(endDate.getDate() - 180);
                        break;
                    case 'YTD':
                        startDate.setMonth(0, 1); // January 1st
                        break;
                    default:
                        startDate.setDate(endDate.getDate() - 30);
                }

                const priceHistory = await fetchHistoricalPricesForSymbol(symbol, startDate, endDate);
                if (!priceHistory) {
                    console.error(`No historical data available for ${symbol}`);
                    return null;
                }

                return priceHistory.map(item => ({
                    date: item.date,
                    price: item.price
                }));

            } catch (error) {
                console.error(`Error fetching historical data for ${symbol}:`, error);
                showToast(`${symbol} 无法获取历史数据`, 'error');
                return null;
            }
        }

        // Generate mock historical data for demo purposes
        function generateMockHistoricalData(symbol, period = '1M') {
            const days = period === '1M' ? 30 : 7;
            const data = [];
            const today = new Date();

            // Get current price from cache or use a default
            let currentPrice = priceCache.get(symbol)?.price;
            if (!currentPrice) {
                // If no cached price, find it from portfolio or use demo prices
                const stockInPortfolio = portfolio.find(s => s.symbol === symbol);
                currentPrice = stockInPortfolio?.currentPrice || 150; // Default fallback
            }

            // Start with a price 30 days ago and build realistic movement
            let startPrice = currentPrice * (0.9 + Math.random() * 0.2); // ±10% from current

            for (let i = days - 1; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(today.getDate() - i);

                // Generate realistic price movement that trends toward current price
                const daysFromEnd = i;
                const progressToPresent = (days - 1 - daysFromEnd) / (days - 1);

                // Blend between start price and current price with some random walk
                const targetPrice = startPrice + (currentPrice - startPrice) * progressToPresent;
                const volatility = 0.015; // 1.5% daily volatility
                const dailyChange = (Math.random() - 0.5) * 2 * volatility;

                let price;
                if (i === 0) {
                    // Last day should be very close to current price
                    price = currentPrice * (0.995 + Math.random() * 0.01);
                } else {
                    price = targetPrice * (1 + dailyChange);
                }

                data.push({
                    date: date.toISOString().split('T')[0],
                    price: Math.max(price, 1) // Ensure positive price
                });
            }

            return data;
        }

        async function addStock() {
            const symbol = document.getElementById('stockSymbol').value.toUpperCase();
            const shares = parseFloat(document.getElementById('shares').value);
            const buyPrice = parseFloat(document.getElementById('buyPrice').value);
            const feePerShare = parseFloat(document.getElementById('initialFee').value) || 0;
            const buyDate = document.getElementById('buyDate').value;

            if (!symbol || !shares || !buyPrice || !buyDate) {
                showToast('请填写所有必填字段', 'error');
                return;
            }

            // Calculate total cost including fees
            const totalCost = (shares * buyPrice) + (shares * feePerShare);

            // Check if user has enough cash
            if (totalCost > cashBalance) {
                showToast(`现金余额不足！需要 $${totalCost.toFixed(2)}，但只有 $${cashBalance.toFixed(2)}`, 'error');
                return;
            }

            // Show loading
            showToast('正在获取最新价格...', 'success');

            try {
                // Fetch current price
                const currentPrice = await fetchStockPrice(symbol);

                // Calculate total fee but don't include in displayed buy price
                const totalFee = shares * feePerShare;

                // Check if this stock already exists in portfolio
                const existingStock = portfolio.find(s => s.symbol === symbol);

                if (existingStock) {
                    // 合并相同股票：计算加权平均成本
                    const oldTotalCost = existingStock.shares * existingStock.buyPrice;
                    const newTotalCost = shares * buyPrice;
                    const combinedShares = existingStock.shares + shares;
                    const weightedAvgPrice = (oldTotalCost + newTotalCost + totalFee) / combinedShares;

                    // 更新现有股票
                    existingStock.shares = combinedShares;
                    existingStock.buyPrice = weightedAvgPrice;
                    existingStock.currentPrice = currentPrice;
                    existingStock.lastUpdate = new Date().toISOString();

                    showToast(`已合并 ${symbol} 股票，新的平均成本价：$${weightedAvgPrice.toFixed(2)}`, 'success');
                } else {
                    // 新股票：创建新的投资组合条目
                    const stock = {
                        id: Date.now(),
                        symbol,
                        companyName: companyNames[symbol] || symbol,
                        shares,
                        buyPrice: (buyPrice * shares + totalFee) / shares, // Include fees in cost basis
                        currentPrice,
                        previousClose: currentPrice, // For daily change calculation
                        buyDate,
                        lastUpdate: new Date().toISOString()
                    };

                    portfolio.push(stock);
                }

                // Record initial buy transaction
                const transaction = {
                    id: Date.now() + 1, // Slightly different ID to avoid collision
                    stockSymbol: symbol,
                    type: 'buy',
                    shares: shares,
                    price: buyPrice,
                    feePerShare: feePerShare,
                    totalFee: totalFee,
                    totalValue: buyPrice * shares,
                    realizedProfit: 0,
                    date: buyDate + 'T12:00:00.000Z',
                    note: '初始买入'
                };

                transactionHistory.push(transaction);

                // Deduct cash for purchase
                cashBalance -= totalCost;
                saveCashBalance();

                savePortfolio();
                saveTransactionHistory();
                updateDisplay();
                clearForm();
                showToast(`成功添加 ${symbol} 到投资组合！已扣除 $${totalCost.toFixed(2)}`, 'success');
            } catch (error) {
                showToast('获取股票价格失败，请稍后重试', 'error');
            }
        }

        function quickFillDemo() {
            const demos = [
                { symbol: 'AAPL', shares: 10, buyPrice: 175 },
                { symbol: 'MSFT', shares: 5, buyPrice: 380 },
                { symbol: 'NVDA', shares: 3, buyPrice: 750 },
                { symbol: 'TSLA', shares: 8, buyPrice: 220 }
            ];
            
            const demo = demos[Math.floor(Math.random() * demos.length)];
            document.getElementById('stockSymbol').value = demo.symbol;
            document.getElementById('shares').value = demo.shares;
            document.getElementById('buyPrice').value = demo.buyPrice;
            
            // Set date to 30 days ago
            const date = new Date();
            date.setDate(date.getDate() - 30);
            document.getElementById('buyDate').value = date.toISOString().split('T')[0];
        }

        function clearForm() {
            document.getElementById('stockSymbol').value = '';
            document.getElementById('shares').value = '';
            document.getElementById('buyPrice').value = '';
            document.getElementById('initialFee').value = '0';
            document.getElementById('buyDate').value = '';
        }

        async function refreshAllPrices() {
            if (portfolio.length === 0) {
                showToast('投资组合为空', 'error');
                return;
            }

            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '🔄 更新中... <span class="loading"></span>';

            try {
                // For Alpha Vantage free tier, we need to respect rate limits
                // Free tier: 5 API calls per minute, 500 calls per day
                
                if (portfolio.length > 5) {
                    showToast(`需要更新 ${portfolio.length} 支股票，由于API限制，这可能需要 ${Math.ceil(portfolio.length / 5)} 分钟`, 'warning');
                }
                
                // Get unique symbols
                const symbols = [...new Set(portfolio.map(stock => stock.symbol))];
                const prices = await fetchMultiplePrices(symbols);
                
                // Update portfolio with new prices
                for (let stock of portfolio) {
                    if (prices[stock.symbol] !== null) {
                        stock.previousClose = stock.currentPrice;
                        stock.currentPrice = prices[stock.symbol];
                        stock.lastUpdate = new Date().toISOString();
                    }
                }
                
                savePortfolio();
                updateDisplay();
                lastUpdateTime = new Date();
                showToast('所有价格已更新！', 'success');
            } catch (error) {
                console.error('Refresh error:', error);
                showToast('更新失败，请稍后重试', 'error');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '🔄 刷新所有价格';
            }
        }

        // Execute buy more operation
        function executeBuyMore(id, additionalShares, price, feePerShare = 0) {
            const stock = portfolio.find(s => s.id === id);
            if (!stock) return;

            // Calculate purchase cost including fees
            const purchaseCost = (additionalShares * price) + (additionalShares * feePerShare);

            // Check if user has enough cash
            if (purchaseCost > cashBalance) {
                showToast(`现金余额不足！需要 $${purchaseCost.toFixed(2)}，但只有 $${cashBalance.toFixed(2)}`, 'error');
                return;
            }

            // Calculate total fee for this transaction
            const totalFee = additionalShares * feePerShare;

            // Calculate new average buy price (including fees)
            const totalCost = (stock.shares * stock.buyPrice) + (additionalShares * price) + totalFee;
            const totalShares = stock.shares + additionalShares;
            const newAvgPrice = totalCost / totalShares;

            // Update stock data
            stock.shares = totalShares;
            stock.buyPrice = newAvgPrice;

            // Record transaction
            const transaction = {
                id: Date.now(),
                stockSymbol: stock.symbol,
                type: 'buy',
                shares: additionalShares,
                price: price,
                feePerShare: feePerShare,
                totalFee: totalFee,
                totalValue: price * additionalShares,
                realizedProfit: 0,
                date: new Date().toISOString(),
                note: '加仓'
            };

            transactionHistory.push(transaction);

            // Deduct cash for purchase
            cashBalance -= purchaseCost;
            saveCashBalance();

            savePortfolio();
            saveTransactionHistory();
            updateDisplay();
            showToast(`${stock.symbol} 加仓成功！新持股: ${totalShares.toFixed(2)}股，平均成本: $${newAvgPrice.toFixed(2)} (含手续费: $${totalFee.toFixed(2)})`, 'success');
        }

        // Execute sell part operation
        function executeSellPart(id, sellShares, price, feePerShare = 0) {
            const stock = portfolio.find(s => s.id === id);
            if (!stock) return;

            // Calculate total fee for this transaction
            const totalFee = sellShares * feePerShare;
            const realizedProfit = (price - stock.buyPrice) * sellShares - totalFee;

            // Update stock data
            stock.shares -= sellShares;

            // Record transaction
            const transaction = {
                id: Date.now(),
                stockSymbol: stock.symbol,
                type: 'sell',
                shares: sellShares,
                price: price,
                feePerShare: feePerShare,
                totalFee: totalFee,
                totalValue: price * sellShares,
                realizedProfit: realizedProfit,
                date: new Date().toISOString(),
                note: '减仓'
            };

            transactionHistory.push(transaction);
            totalRealizedProfit += realizedProfit;

            // Add cash from sale (total sale amount minus fees)
            const saleProceeds = (price * sellShares) - totalFee;
            cashBalance += saleProceeds;
            saveCashBalance();

            savePortfolio();
            saveTransactionHistory();
            updateDisplay();
            showToast(`${stock.symbol} 减仓成功！剩余持股: ${stock.shares.toFixed(2)}股，实现${realizedProfit >= 0 ? '盈利' : '亏损'} $${Math.abs(realizedProfit).toFixed(2)} (含手续费: $${totalFee.toFixed(2)})`, realizedProfit >= 0 ? 'success' : 'warning');
        }

        // Execute delete (clear all) operation
        function executeDelete(id, salePrice, feePerShare = 0) {
            const stock = portfolio.find(s => s.id === id);
            if (!stock) return;

            // Calculate total fee for this transaction
            const totalFee = stock.shares * feePerShare;
            const realizedProfit = (salePrice - stock.buyPrice) * stock.shares - totalFee;

            const transaction = {
                id: Date.now(),
                stockSymbol: stock.symbol,
                type: 'sell',
                shares: stock.shares,
                price: salePrice,
                feePerShare: feePerShare,
                totalFee: totalFee,
                totalValue: salePrice * stock.shares,
                realizedProfit: realizedProfit,
                date: new Date().toISOString(),
                note: '清仓'
            };

            transactionHistory.push(transaction);
            totalRealizedProfit += realizedProfit;

            // Add cash from sale (total sale amount minus fees)
            const saleProceeds = (salePrice * stock.shares) - totalFee;
            cashBalance += saleProceeds;
            saveCashBalance();

            portfolio = portfolio.filter(s => s.id !== id);
            savePortfolio();
            saveTransactionHistory();
            updateDisplay();
            showToast(`${stock.symbol} 已清仓，实现${realizedProfit >= 0 ? '盈利' : '亏损'} $${Math.abs(realizedProfit).toFixed(2)} (含手续费: $${totalFee.toFixed(2)})`, realizedProfit >= 0 ? 'success' : 'warning');
        }

        function updateDisplay() {
            const tbody = document.getElementById('portfolioBody');
            
            if (portfolio.length === 0) {
                tbody.innerHTML = `
                    <tr class="empty-state">
                        <td colspan="12">
                            <h3>📭 暂无持仓</h3>
                            <p>使用上方表单添加您的第一支股票</p>
                            <p style="margin-top: 10px; color: #666;">支持美股实时价格自动更新</p>
                        </td>
                    </tr>
                `;

                // Calculate principal (total deposits only) even when no stocks
                let totalDeposits = 0;
                let totalWithdrawals = 0;
                transactionHistory.forEach(transaction => {
                    if (transaction.type === 'cash_deposit') {
                        totalDeposits += transaction.amount;
                    } else if (transaction.type === 'cash_withdrawal') {
                        totalWithdrawals += Math.abs(transaction.amount);
                    }
                });
                const principal = totalDeposits - totalWithdrawals; // Principal = deposits - withdrawals
                const currentValue = cashBalance; // Only cash when no stocks
                const totalReturn = 0; // No stock returns when no stocks
                const returnPercent = 0; // No returns when no stocks

                updateSummary(principal, currentValue, totalReturn, returnPercent, 0, 0);
                updateChart([]);
                updateCashDisplay();
                return;
            }

            let totalInvestment = 0;
            let totalCurrentValue = 0;
            let totalDailyChange = 0;

            // Calculate total investment (principal) as total deposits only
            let totalDeposits = 0;
            let totalWithdrawals = 0;
            transactionHistory.forEach(transaction => {
                if (transaction.type === 'cash_deposit') {
                    totalDeposits += transaction.amount;
                } else if (transaction.type === 'cash_withdrawal') {
                    totalWithdrawals += Math.abs(transaction.amount);
                }
            });
            totalInvestment = totalDeposits - totalWithdrawals; // Principal = deposits - withdrawals

            // Calculate stock investment and value totals (excluding cash)
            let totalStockInvestment = 0;
            let totalStockValue = 0;
            portfolio.forEach(stock => {
                totalStockInvestment += stock.shares * stock.buyPrice;
                totalStockValue += stock.shares * stock.currentPrice;
            });

            // Total current value includes stocks + cash for portfolio distribution
            totalCurrentValue = totalStockValue + cashBalance;

            // Build table rows
            tbody.innerHTML = portfolio.map(stock => {
                const investment = stock.shares * stock.buyPrice;
                const currentValue = stock.shares * stock.currentPrice;
                const returnDollar = currentValue - investment;
                const returnPercent = ((returnDollar / investment) * 100).toFixed(2);
                const weight = ((currentValue / totalCurrentValue) * 100).toFixed(2);
                const dailyChange = stock.previousClose ? 
                    (stock.currentPrice - stock.previousClose) * stock.shares : 0;
                
                // Calculate holding days
                const buyDate = new Date(stock.buyDate);
                const today = new Date();
                const holdingDays = Math.floor((today - buyDate) / (1000 * 60 * 60 * 24));
                totalDailyChange += dailyChange;

                const returnClass = returnDollar >= 0 ? 'positive' : 'negative';
                const dailyClass = dailyChange >= 0 ? 'positive' : 'negative';
                const returnSymbol = returnDollar >= 0 ? '↑' : '↓';

                return `
                    <tr>
                        <td><span class="stock-symbol">${stock.symbol}</span></td>
                        <td>${stock.companyName}</td>
                        <td>${stock.shares.toFixed(2)}</td>
                        <td>${stock.buyPrice.toFixed(2)}</td>
                        <td>${stock.currentPrice.toFixed(2)}</td>
                        <td>${investment.toFixed(2)}</td>
                        <td>${currentValue.toFixed(2)}</td>
                        <td class="${returnClass}">${returnSymbol} ${Math.abs(returnDollar).toFixed(2)}</td>
                        <td class="${returnClass}">${returnSymbol} ${Math.abs(returnPercent)}%</td>
                        <td><strong>${weight}%</strong></td>
                        <td>${holdingDays} 天</td>
                        <td>
                            <div class="action-buttons">
                                <button class="buy-more-btn" onclick="buyMoreStock(${stock.id})" title="加仓">📈 加仓</button>
                                <button class="sell-part-btn" onclick="sellPartStock(${stock.id})" title="减仓">📉 减仓</button>
                                <button class="delete-btn" onclick="deleteStock(${stock.id})" title="清仓">🗑️ 清仓</button>
                            </div>
                        </td>
                    </tr>
                    <tr class="stock-chart-row">
                        <td colspan="12">
                            <div class="stock-detail-header" onclick="toggleStockDetails(${stock.id})">
                                <span class="detail-toggle-icon" id="toggle-${stock.id}">▼</span>
                                <span class="detail-title">${stock.symbol} 详细信息与走势图</span>
                                <span class="detail-subtitle">点击展开/收起</span>
                            </div>
                            <div class="stock-detail-container" id="details-${stock.id}" style="display: none;">
                                <div class="stock-specs">
                                    <h4>${stock.symbol} 详细信息</h4>
                                    <div class="specs-grid" id="specs-${stock.id}">
                                        <div class="spec-section">
                                            <div class="spec-item">
                                                <span class="spec-label">前收盘</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">开盘</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">日波动</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">52周波动</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">成交量</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                        </div>
                                        <div class="spec-section">
                                            <div class="spec-item">
                                                <span class="spec-label">市值</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">Beta (5年)</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">市盈率 (TTM)</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">每股收益 (TTM)</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">货币</span>
                                                <span class="spec-value loading-data">加载中...</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="stock-chart-container">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                        <h4>${stock.symbol} 价格走势</h4>
                                        <div class="time-selector light" id="stockTimeSelector-${stock.id}">
                                            <button class="time-btn light" data-period="1D" onclick="onStockTimeRangeChange('${stock.id}', '1D')">日线</button>
                                            <button class="time-btn light" data-period="1W" onclick="onStockTimeRangeChange('${stock.id}', '1W')">周线</button>
                                            <button class="time-btn light active" data-period="1M" onclick="onStockTimeRangeChange('${stock.id}', '1M')">月线</button>
                                            <button class="time-btn light" data-period="3M" onclick="onStockTimeRangeChange('${stock.id}', '3M')">季线</button>
                                            <button class="time-btn light" data-period="6M" onclick="onStockTimeRangeChange('${stock.id}', '6M')">半年线</button>
                                            <button class="time-btn light" data-period="YTD" onclick="onStockTimeRangeChange('${stock.id}', 'YTD')">今年</button>
                                        </div>
                                    </div>
                                    <div class="chart-wrapper">
                                        <canvas id="chart-${stock.id}"></canvas>
                                    </div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');

            // Total returns should only reflect stock performance, not cash changes
            const totalReturn = totalStockValue - totalStockInvestment;
            const totalReturnPercent = totalStockInvestment > 0 ? (totalReturn / totalStockInvestment) * 100 : 0;

            updateSummary(totalInvestment, totalCurrentValue, totalReturn, totalReturnPercent, totalDailyChange, portfolio.length);
            updateChart(portfolio);

            // Update portfolio trend chart if we have transaction history
            if (transactionHistory.length > 0) {
                setTimeout(() => updatePortfolioTrendChart(), 1000);
            }

            // Render individual stock charts with proper timing
            requestAnimationFrame(() => {
                setTimeout(() => {
                    portfolio.forEach(stock => {
                        renderStockChart(stock);
                    });
                }, 200); // Increased delay to ensure DOM is fully updated
            });

            // Update last update time
            if (lastUpdateTime) {
                document.getElementById('lastUpdate').textContent =
                    new Date(lastUpdateTime).toLocaleString('zh-CN');
            }
        }

        function updateSummary(investment, currentValue, totalReturn, returnPercentage, dailyChange, stockCount) {
            document.getElementById('totalInvestment').textContent = `${investment.toFixed(2)}`;
            document.getElementById('currentValue').textContent = `${currentValue.toFixed(2)}`;
            document.getElementById('stockCount').textContent = stockCount.toString();

            // Calculate total fees from transaction history
            const totalFees = transactionHistory.reduce((sum, transaction) => {
                return sum + (transaction.totalFee || 0);
            }, 0);
            document.getElementById('totalFees').textContent = `$${totalFees.toFixed(2)}`;

            const returnElement = document.getElementById('totalReturn');
            const returnCard = document.getElementById('totalReturnCard');

            const returnSymbol = totalReturn >= 0 ? '↑' : '↓';

            returnElement.textContent = `${returnSymbol} ${Math.abs(totalReturn).toFixed(2)}`;

            if (totalReturn >= 0) {
                returnCard.classList.add('profit');
                returnCard.classList.remove('loss');
            } else {
                returnCard.classList.add('loss');
                returnCard.classList.remove('profit');
            }

            // Update cash balance display
            updateCashDisplay();
        }

        function updateCashDisplay() {
            document.getElementById('cashBalance').textContent = `$${cashBalance.toFixed(2)}`;
            document.getElementById('currentCashDisplay').textContent = cashBalance.toFixed(2);
        }

        function initChart() {
            const ctx = document.getElementById('portfolioChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: [
                            '#FF6384',
                            '#36A2EB',
                            '#FFCE56',
                            '#4BC0C0',
                            '#9966FF',
                            '#FF9F40',
                            '#FF6384',
                            '#C9CBCF',
                            '#4BC0C0',
                            '#FF6384'
                        ],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                padding: 15,
                                font: {
                                    size: 12
                                },
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const value = data.datasets[0].data[i];
                                            const percentage = data.datasets[0].percentages ? data.datasets[0].percentages[i] : '';
                                            return {
                                                text: `${label}: ${percentage}%`,
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                hidden: false,
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = '$' + context.parsed.toFixed(2);
                                    const percentage = context.dataset.percentages ? 
                                        context.dataset.percentages[context.dataIndex] + '%' : '';
                                    return `${label}: ${value} (${percentage})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateChart(stocks) {
            if (!chartInstance) return;

            let totalValue = 0;
            stocks.forEach(stock => {
                totalValue += stock.shares * stock.currentPrice;
            });

            // Add cash balance to total value
            totalValue += cashBalance;

            const labels = [];
            const data = [];
            const percentages = [];

            // Add stock holdings
            stocks.forEach(stock => {
                const value = stock.shares * stock.currentPrice;
                const percentage = ((value / totalValue) * 100).toFixed(1);

                labels.push(stock.symbol);
                data.push(value);
                percentages.push(percentage);
            });

            // Handle case when no stocks are held
            if (stocks.length === 0) {
                // Show 100% principal when no stocks
                if (totalValue > 0) {
                    labels.push('本金');
                    data.push(totalValue);
                    percentages.push('100.0');
                } else {
                    // If no cash and no stocks, show empty chart
                    chartInstance.data.labels = [];
                    chartInstance.data.datasets[0].data = [];
                    chartInstance.data.datasets[0].percentages = [];
                    chartInstance.update();
                    return;
                }
            } else {
                // Add cash balance to chart if there's any cash and we have stocks
                if (cashBalance > 0) {
                    const cashPercentage = ((cashBalance / totalValue) * 100).toFixed(1);
                    labels.push('现金');
                    data.push(cashBalance);
                    percentages.push(cashPercentage);
                }
            }

            chartInstance.data.labels = labels;
            chartInstance.data.datasets[0].data = data;
            chartInstance.data.datasets[0].percentages = percentages;
            chartInstance.update();
        }

        // Initialize Portfolio Trend Chart
        function initPortfolioTrendChart() {
            const ctx = document.getElementById('portfolioTrendChart').getContext('2d');
            portfolioTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '当前市值',
                        data: [],
                        borderColor: '#4F46E5',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#4F46E5',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    }, {
                        label: '本金',
                        data: [],
                        borderColor: '#EF4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        pointBackgroundColor: '#EF4444',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 15,
                                padding: 20,
                                font: { size: 14, weight: '500' }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#4F46E5',
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12,
                            callbacks: {
                                title: function(context) {
                                    return '日期: ' + context[0].label;
                                },
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = '$' + context.parsed.y.toFixed(2);
                                    return `${label}: ${value}`;
                                },
                                afterBody: function(context) {
                                    if (context.length === 2) {
                                        const portfolioValue = context[0].parsed.y;
                                        const costValue = context[1].parsed.y;
                                        const profit = portfolioValue - costValue;
                                        const profitPercent = costValue > 0 ? ((profit / costValue) * 100).toFixed(2) : '0.00';
                                        return [``, `盈亏: ${profit >= 0 ? '+' : ''}$${profit.toFixed(2)}`, `收益率: ${profit >= 0 ? '+' : ''}${profitPercent}%`];
                                    }
                                    return [];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                font: { size: 12 },
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                font: { size: 12 },
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            }
                        }
                    }
                }
            });
        }

        // Calculate historical portfolio values based on transactions and REAL historical prices
        async function calculateHistoricalPortfolioValues() {
            if (transactionHistory.length === 0) {
                return [];
            }

            // Sort transactions by date
            const sortedTransactions = [...transactionHistory].sort((a, b) => new Date(a.date) - new Date(b.date));

            // Get date range - start from first transaction, go to today
            const startDate = new Date(sortedTransactions[0].date);
            const endDate = new Date();

            // Get all unique symbols that have been traded
            const allSymbols = [...new Set(sortedTransactions.map(t => t.stockSymbol))];

            // Fetch historical price data for all symbols
            const historicalPriceData = new Map();

            showToast('正在获取历史价格数据...', 'success');

            for (const symbol of allSymbols) {
                try {
                    const priceHistory = await fetchHistoricalPricesForSymbol(symbol, startDate, endDate);
                    if (priceHistory && priceHistory.length > 0) {
                        historicalPriceData.set(symbol, priceHistory);
                        console.log(`获取 ${symbol} 历史价格数据: ${priceHistory.length} 个数据点`);
                    } else {
                        console.warn(`无法获取 ${symbol} 历史价格数据，跳过该股票的组合走势图计算`);
                        showToast(`⚠️ ${symbol} 无历史数据，组合走势图可能不完整`, 'warning');
                        // 不添加任何数据，直接跳过这个股票
                    }
                } catch (error) {
                    console.warn(`无法获取 ${symbol} 历史价格数据:`, error);
                    showToast(`❌ ${symbol} 历史数据获取失败，跳过该股票`, 'error');
                    // 不使用模拟数据，直接跳过
                }
            }

            // Build daily portfolio snapshots
            const historicalValues = [];
            let currentHoldings = new Map(); // symbol -> { shares, avgCost }
            let currentCashBalance = 0; // Track cash balance over time

            // Process each day from start to end
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toISOString().split('T')[0];

                // Apply any transactions that occurred on this date
                const dayTransactions = sortedTransactions.filter(t =>
                    t.date.split('T')[0] === dateStr
                );

                dayTransactions.forEach(transaction => {
                    if (transaction.type === 'cash_deposit') {
                        // Cash deposit increases cash balance
                        currentCashBalance += transaction.amount;
                    } else if (transaction.type === 'cash_withdrawal') {
                        // Cash withdrawal decreases cash balance
                        currentCashBalance -= Math.abs(transaction.amount);
                    } else if (transaction.stockSymbol) {
                        // Stock transactions
                        const symbol = transaction.stockSymbol;
                        const holding = currentHoldings.get(symbol) || { shares: 0, avgCost: 0 };

                        if (transaction.type === 'buy') {
                            // Calculate new average cost
                            const totalCost = (holding.shares * holding.avgCost) + transaction.totalValue;
                            const totalShares = holding.shares + transaction.shares;
                            holding.avgCost = totalShares > 0 ? totalCost / totalShares : transaction.price;
                            holding.shares = totalShares;
                            // Buying stocks reduces cash balance
                            currentCashBalance -= transaction.totalValue;
                        } else if (transaction.type === 'sell') {
                            holding.shares -= transaction.shares;
                            // Selling stocks increases cash balance
                            currentCashBalance += transaction.totalValue;
                            // Average cost stays the same when selling
                            if (holding.shares <= 0) {
                                currentHoldings.delete(symbol);
                                return;
                            }
                        }

                        if (holding.shares > 0) {
                            currentHoldings.set(symbol, holding);
                        }
                    }
                });

                // Skip weekends for cleaner chart
                if (d.getDay() === 0 || d.getDay() === 6) continue;

                // Calculate total asset value for this date (stocks + cash)
                if (currentHoldings.size > 0 || currentCashBalance > 0) {
                    let stockValue = 0;
                    let stockCost = 0;
                    let hasAllPrices = true;

                    // Calculate stock values and costs
                    for (const [symbol, holding] of currentHoldings) {
                        const priceHistory = historicalPriceData.get(symbol);
                        const dayPrice = findPriceForDate(priceHistory, dateStr);

                        if (dayPrice && dayPrice > 0) {
                            stockValue += holding.shares * dayPrice;
                            stockCost += holding.shares * holding.avgCost;
                        } else {
                            hasAllPrices = false;
                            break;
                        }
                    }

                    // Calculate total principal (deposits - withdrawals) up to this date
                    let totalPrincipal = 0;
                    sortedTransactions.forEach(t => {
                        if (new Date(t.date) <= d) {
                            if (t.type === 'cash_deposit') {
                                totalPrincipal += t.amount;
                            } else if (t.type === 'cash_withdrawal') {
                                totalPrincipal -= Math.abs(t.amount);
                            }
                        }
                    });

                    // Include cash balance in total asset value
                    const totalAssetValue = stockValue + Math.max(0, currentCashBalance);
                    // Total cost should be just the principal (cash investments only)
                    const totalCost = Math.max(0, totalPrincipal);

                    if ((currentHoldings.size === 0 || hasAllPrices) && totalAssetValue > 0) {
                        historicalValues.push({
                            date: dateStr,
                            portfolioValue: totalAssetValue, // Total asset value (stocks + cash)
                            totalCost: totalCost, // Total invested cost (stock costs + cash principal)
                            holdings: Array.from(currentHoldings.entries()),
                            cashBalance: Math.max(0, currentCashBalance)
                        });
                    }
                }
            }

            return historicalValues;
        }

        // Fetch historical data from Financial Modeling Prep API
        async function fetchHistoricalFromFMP(symbol, startDate, endDate) {
            const dateFrom = startDate.toISOString().split('T')[0];
            const dateTo = endDate.toISOString().split('T')[0];

            try {
                // Using Financial Modeling Prep free tier with better error handling
                const url = `https://financialmodelingprep.com/api/v3/historical-price-full/${symbol}?from=${dateFrom}&to=${dateTo}&apikey=demo`;
                console.log(`Fetching FMP data: ${url}`);

                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                    // Add timeout to prevent hanging requests
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    console.error(`FMP API Error: ${response.status} - ${response.statusText}`);
                    throw new Error(`FMP HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('FMP Response:', data);

                // Check for API error messages
                if (data.error || data.message) {
                    throw new Error(`FMP API Error: ${data.error || data.message}`);
                }

                if (!data.historical || !Array.isArray(data.historical) || data.historical.length === 0) {
                    throw new Error('No historical data available from FMP');
                }

                const historicalData = data.historical.map(item => ({
                    date: item.date,
                    price: parseFloat(item.close) || 0
                })).filter(item => item.price > 0).sort((a, b) => new Date(a.date) - new Date(b.date));

                if (historicalData.length === 0) {
                    throw new Error('No valid historical data points from FMP');
                }

                return historicalData;

            } catch (error) {
                console.error(`FMP fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // Fetch historical data from Finnhub
        async function fetchHistoricalFromFinnhub(symbol, startDate, endDate) {
            try {
                // Convert dates to Unix timestamps (Finnhub requirement)
                const from = Math.floor(startDate.getTime() / 1000);
                const to = Math.floor(endDate.getTime() / 1000);

                const url = `https://finnhub.io/api/v1/stock/candle?symbol=${symbol}&resolution=D&from=${from}&to=${to}&token=${FINNHUB_API_KEY}`;

                console.log(`Fetching Finnhub data: ${url}`);

                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'X-Finnhub-Token': FINNHUB_API_KEY
                    },
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    console.error(`Finnhub API Error: ${response.status} - ${response.statusText}`);
                    throw new Error(`Finnhub HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Finnhub Response:', data);

                // Check for API error
                if (data.s === 'no_data') {
                    throw new Error('No data available for this symbol');
                }

                if (data.s !== 'ok') {
                    throw new Error(`Finnhub API Error: ${data.s}`);
                }

                if (!data.c || !data.t || data.c.length === 0) {
                    throw new Error('Invalid Finnhub response format');
                }

                // Convert Finnhub format to our format
                const historicalData = [];
                for (let i = 0; i < data.c.length; i++) {
                    const date = new Date(data.t[i] * 1000); // Convert Unix timestamp to Date
                    const price = parseFloat(data.c[i]); // Close price

                    if (!isNaN(price) && price > 0) {
                        historicalData.push({
                            date: date.toISOString().split('T')[0], // YYYY-MM-DD format
                            price: price
                        });
                    }
                }

                return historicalData.sort((a, b) => new Date(a.date) - new Date(b.date));

            } catch (error) {
                console.error(`Finnhub fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // Fetch real historical prices for a symbol using multiple APIs
        // Fetch historical data from Yahoo Finance (free alternative)
        async function fetchHistoricalFromYahoo(symbol, startDate, endDate) {
            try {
                const period1 = Math.floor(startDate.getTime() / 1000);
                const period2 = Math.floor(endDate.getTime() / 1000);

                // Use CORS proxy for Yahoo Finance
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const yahooUrl = `https://query1.finance.yahoo.com/v7/finance/download/${symbol}?period1=${period1}&period2=${period2}&interval=1d&events=history&includeAdjustedClose=true`;
                const url = proxyUrl + encodeURIComponent(yahooUrl);

                console.log(`Fetching Yahoo historical data via proxy: ${symbol}`);

                const response = await fetch(url, {
                    method: 'GET',
                    signal: AbortSignal.timeout(15000) // Increase timeout for proxy
                });

                if (!response.ok) {
                    throw new Error(`Yahoo HTTP ${response.status}`);
                }

                const csvText = await response.text();

                // Check if response is actually CSV data
                if (!csvText || csvText.includes('error') || csvText.includes('404')) {
                    throw new Error('Invalid Yahoo response or symbol not found');
                }

                const lines = csvText.trim().split('\n');

                if (lines.length < 2) {
                    throw new Error('No historical data in Yahoo response');
                }

                const historicalData = [];
                for (let i = 1; i < lines.length; i++) {
                    const columns = lines[i].split(',');
                    if (columns.length < 5) continue; // Skip invalid lines

                    const [date, , , , close] = columns;
                    const price = parseFloat(close);

                    if (!isNaN(price) && price > 0 && date) {
                        historicalData.push({
                            date: date,
                            price: price
                        });
                    }
                }

                if (historicalData.length === 0) {
                    throw new Error('No valid price data found in Yahoo response');
                }

                return historicalData.sort((a, b) => new Date(a.date) - new Date(b.date));

            } catch (error) {
                console.error(`Yahoo historical fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // Fetch from Polygon.io (another free option)
        async function fetchHistoricalFromPolygon(symbol, startDate, endDate) {
            try {
                const from = startDate.toISOString().split('T')[0];
                const to = endDate.toISOString().split('T')[0];
                // Using free tier - limited but may work
                const url = `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/1/day/${from}/${to}?adjusted=true&sort=asc&apikey=demo`;

                console.log(`Fetching Polygon data: ${url}`);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    throw new Error(`Polygon HTTP ${response.status}`);
                }

                const data = await response.json();

                if (!data.results || !Array.isArray(data.results)) {
                    throw new Error('No results from Polygon');
                }

                return data.results.map(item => ({
                    date: new Date(item.t).toISOString().split('T')[0],
                    price: item.c
                })).sort((a, b) => new Date(a.date) - new Date(b.date));

            } catch (error) {
                console.error(`Polygon fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // Alpha Vantage backup for historical data
        async function fetchHistoricalFromAlphaVantage(symbol, startDate, endDate) {
            try {
                const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&apikey=demo&outputsize=full`;

                console.log(`Fetching Alpha Vantage historical data: ${symbol}`);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    throw new Error(`Alpha Vantage HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data['Note'] || data['Information']) {
                    throw new Error('Alpha Vantage API limit reached');
                }

                if (!data['Time Series (Daily)']) {
                    throw new Error('No historical data found in Alpha Vantage response');
                }

                const timeSeries = data['Time Series (Daily)'];
                const priceHistory = [];

                // Convert to our format
                for (const [date, dayData] of Object.entries(timeSeries)) {
                    const dateObj = new Date(date);
                    if (dateObj >= startDate && dateObj <= endDate) {
                        priceHistory.push({
                            date: date,
                            price: parseFloat(dayData['4. close'])
                        });
                    }
                }

                return priceHistory.sort((a, b) => new Date(a.date) - new Date(b.date));

            } catch (error) {
                console.error(`Alpha Vantage historical fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // 使用API获取历史数据（按周期）
        async function fetchHistoricalFromLocalAPIByPeriod(symbol, period = '1M') {
            try {
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const url = `${apiUrl}/api/history/${symbol}?period=${period}`;
                console.log(`🔄 正在从API获取 ${symbol} 历史数据 (${period}): ${url}`);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    // 转换为期望的格式
                    const priceHistory = data.data.map(item => ({
                        date: item.date,
                        price: item.close
                    }));

                    console.log(`✅ 本地API获取到 ${symbol} 历史数据 (${period}): ${priceHistory.length} 个数据点`);
                    return priceHistory;
                } else {
                    console.warn(`⚠️ 本地API返回数据格式异常:`, data);
                    return null;
                }
            } catch (error) {
                console.error(`❌ 本地API获取 ${symbol} 历史数据失败:`, error);
                return null;
            }
        }

        // 使用本地API获取历史数据（按日期范围）- 保持向后兼容
        async function fetchHistoricalFromLocalAPI(symbol, startDate, endDate) {
            try {
                const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                const days = Math.min(Math.max(daysDiff, 7), 365); // 限制在7-365天之间

                // Convert days to period for new API
                let period = '1M';
                if (days <= 1) period = '1D';
                else if (days <= 7) period = '1W';
                else if (days <= 30) period = '1M';
                else if (days <= 90) period = '3M';
                else if (days <= 180) period = '6M';
                else period = 'YTD';

                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const url = `${apiUrl}/api/history/${symbol}?period=${period}`;
                console.log(`🔄 正在从API获取 ${symbol} 历史数据: ${url}`);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    // 转换为期望的格式
                    const priceHistory = data.data.map(item => ({
                        date: item.date,
                        price: item.close
                    })).filter(item => {
                        const itemDate = new Date(item.date);
                        return itemDate >= startDate && itemDate <= endDate;
                    });

                    console.log(`✅ 本地API获取到 ${symbol} 历史数据: ${priceHistory.length} 个数据点`);
                    return priceHistory;
                } else {
                    console.warn(`⚠️ 本地API返回数据格式异常:`, data);
                    return null;
                }
            } catch (error) {
                console.error(`❌ 本地API获取 ${symbol} 历史数据失败:`, error);
                return null;
            }
        }

        async function fetchHistoricalPricesForSymbol(symbol, startDate, endDate) {
            const historicalAPIs = [
                { name: '本地API服务', fetch: () => fetchHistoricalFromLocalAPI(symbol, startDate, endDate) },
                { name: 'Yahoo Finance', fetch: () => fetchHistoricalFromYahoo(symbol, startDate, endDate) },
                { name: 'Finnhub', fetch: () => fetchHistoricalFromFinnhub(symbol, startDate, endDate) },
                { name: 'Alpha Vantage', fetch: () => fetchHistoricalFromAlphaVantage(symbol, startDate, endDate) }
            ];

            for (const api of historicalAPIs) {
                try {
                    console.log(`🔄 尝试获取 ${symbol} 历史数据 - ${api.name}`);
                    showToast(`🔄 正在从 ${api.name} 获取 ${symbol} 数据...`, 'info');

                    const priceHistory = await api.fetch();

                    if (priceHistory && priceHistory.length > 0) {
                        console.log(`✅ ${api.name} - 获取到 ${symbol} ${priceHistory.length} 个历史数据点`);
                        console.log(`首个数据点:`, priceHistory[0]);
                        console.log(`最后数据点:`, priceHistory[priceHistory.length - 1]);
                        showToast(`✅ ${symbol} 真实历史数据来自 ${api.name} (${priceHistory.length}条)`, 'success');
                        return priceHistory;
                    } else {
                        console.warn(`⚠️ ${api.name} - ${symbol} 返回空数据`);
                    }
                } catch (error) {
                    console.error(`❌ ${api.name} - ${symbol} 历史数据获取失败:`, error);
                    showToast(`❌ ${api.name} 获取失败: ${error.message}`, 'error');
                    continue;
                }
            }

            // If all APIs fail, return null
            console.warn(`所有历史数据API失败，${symbol} 无法获取数据`);
            showToast(`⚠️ ${symbol} 无可用历史数据`, 'warning');
            return null;
        }

        // Generate realistic price history with proper market behavior and more variation
        function generateRealisticPriceHistory(symbol, startDate, endDate) {
            const priceHistory = [];

            // Get current price as end point
            const stock = portfolio.find(s => s.symbol === symbol);
            const currentPrice = stock?.currentPrice || 100;

            // Calculate number of days
            const totalDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));

            // Create more realistic price movements based on symbol characteristics
            const dailyVolatility = getSymbolVolatility(symbol);

            // Start with more variable starting price
            const startPrice = currentPrice * (0.6 + Math.random() * 0.8); // More variation: 60%-140% of current
            let price = startPrice;

            // Calculate overall trend (but allow for more random walks)
            const totalReturn = (currentPrice - startPrice) / startPrice;
            const baseDailyTrend = totalReturn / totalDays;

            // Track momentum and trend changes for more realistic movements
            let momentum = 0;
            let trendDirection = Math.random() > 0.5 ? 1 : -1; // Start with random trend
            const momentumDecay = 0.92; // Slightly faster decay
            let daysInCurrentTrend = 0;

            for (let i = 0; i <= totalDays; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);

                // Skip weekends
                if (date.getDay() !== 0 && date.getDay() !== 6) {
                    // Calculate progress toward end
                    const progress = i / totalDays;

                    // Occasionally change trend direction for more realistic movement
                    daysInCurrentTrend++;
                    if (daysInCurrentTrend > 5 && Math.random() < 0.15) { // 15% chance to change trend after 5 days
                        trendDirection *= -1;
                        daysInCurrentTrend = 0;
                    }

                    // Generate more varied daily changes
                    const randomShock = (Math.random() - 0.5) * 2; // -1 to 1
                    const trendComponent = baseDailyTrend + (trendDirection * dailyVolatility * 0.3);
                    const dailyChange = trendComponent + (randomShock * dailyVolatility);

                    // Add momentum effect with more variation
                    momentum = momentum * momentumDecay + dailyChange * (0.2 + Math.random() * 0.3);
                    let totalChange = dailyChange + momentum * (0.1 + Math.random() * 0.2);

                    // Add market cycles - some periods of higher/lower volatility
                    const cyclePosition = (i / totalDays) * 4 * Math.PI; // 2 full cycles
                    const volatilityMultiplier = 1 + 0.3 * Math.sin(cyclePosition + Math.random());
                    totalChange *= volatilityMultiplier;

                    // Apply change
                    price = price * (1 + totalChange);

                    // Add more frequent larger moves for realism
                    if (Math.random() < 0.08) { // 8% chance of larger move
                        const bigMove = (Math.random() - 0.5) * dailyVolatility * (2 + Math.random() * 3);
                        price = price * (1 + bigMove);
                    }

                    // Ensure price stays within reasonable bounds
                    price = Math.max(price, currentPrice * 0.3);
                    price = Math.min(price, currentPrice * 2.0);

                    // For the final portion, gradually converge to current price (but not too rigidly)
                    if (progress > 0.9) {
                        const convergence = Math.pow((progress - 0.9) / 0.1, 2); // Quadratic convergence
                        const targetPrice = currentPrice * (0.95 + Math.random() * 0.1); // Slight variation from exact current price
                        price = price * (1 - convergence) + targetPrice * convergence;
                    }

                    priceHistory.push({
                        date: date.toISOString().split('T')[0],
                        price: Math.round(price * 100) / 100 // Round to 2 decimal places
                    });
                }
            }

            return priceHistory;
        }

        // Find price for a specific date
        function findPriceForDate(priceHistory, targetDate) {
            if (!priceHistory || priceHistory.length === 0) return null;

            // Find exact match first
            const exactMatch = priceHistory.find(p => p.date === targetDate);
            if (exactMatch) return exactMatch.price;

            // Find closest date (for weekends, use previous trading day)
            const targetDateObj = new Date(targetDate);
            let closest = null;
            let smallestDiff = Infinity;

            for (const priceData of priceHistory) {
                const priceDate = new Date(priceData.date);
                const diff = Math.abs(targetDateObj - priceDate);

                // Prefer earlier dates for weekends
                if (priceDate <= targetDateObj && diff < smallestDiff) {
                    closest = priceData;
                    smallestDiff = diff;
                }
            }

            return closest ? closest.price : priceHistory[priceHistory.length - 1]?.price;
        }

        // Handle time range change
        // Handle Robinhood-style time selector for portfolio trend
        function selectTimeRange(period) {
            // Update button states
            const selector = document.getElementById('portfolioTimeSelector');
            const buttons = selector.querySelectorAll('.time-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.period === period) {
                    btn.classList.add('active');
                }
            });

            // Update current time range and refresh chart
            currentTimeRange = period;

            // Use cached data for fast switching if available
            if (rawHistoricalData.length > 0) {
                refreshWithCachedData();
                showToast(`已切换到${getTimeRangeDisplayName(currentTimeRange)}视图`, 'success');
            } else {
                updatePortfolioTrendChart();
            }
        }

        function onTimeRangeChange() {
            const selector = document.getElementById('timeRangeSelector');
            currentTimeRange = selector.value;

            // Use cached data for fast switching if available
            if (rawHistoricalData.length > 0) {
                refreshWithCachedData();
                showToast(`已切换到${getTimeRangeDisplayName(currentTimeRange)}视图`, 'success');
            } else {
                updatePortfolioTrendChart();
            }
        }

        // Get display name for time range
        function getTimeRangeDisplayName(timeRange) {
            const names = {
                '1D': '日线',
                '1W': '周线',
                '1M': '月线',
                '3M': '季线',
                '6M': '半年线',
                'YTD': '今年到现在',
                '1Y': '年线'
            };
            return names[timeRange] || timeRange;
        }

        // Aggregate data based on time range - fills in missing periods with interpolated data
        function aggregateDataByTimeRange(dailyData, timeRange) {
            if (!dailyData || dailyData.length === 0) return [];

            const now = new Date();
            const result = [];

            // All time ranges show approximately the same time span, but with different granularity
            switch (timeRange) {
                case '1D':
                    // Daily: Show last 15 days
                    return dailyData.slice(-15);

                case '1W':
                    // Weekly: Show last 15 weeks
                    for (let i = 14; i >= 0; i--) {
                        const weekEnd = new Date(now);
                        weekEnd.setDate(now.getDate() - (i * 7));

                        // Find the Friday of this week
                        const dayOfWeek = weekEnd.getDay();
                        const daysToFriday = dayOfWeek === 0 ? -2 : (5 - dayOfWeek);
                        weekEnd.setDate(weekEnd.getDate() + daysToFriday);

                        // Find closest data point for this week
                        const weekData = findClosestDataPoint(dailyData, weekEnd);
                        if (weekData) {
                            result.push({
                                ...weekData,
                                date: weekEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case '1M':
                    // Monthly: Show last 15 months
                    for (let i = 14; i >= 0; i--) {
                        const monthEnd = new Date(now.getFullYear(), now.getMonth() - i + 1, 0);

                        // Find closest data point for this month
                        const monthData = findClosestDataPoint(dailyData, monthEnd);
                        if (monthData) {
                            result.push({
                                ...monthData,
                                date: monthEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case '3M':
                    // Quarterly: Show last 15 quarters (3.75 years)
                    for (let i = 14; i >= 0; i--) {
                        const quarterEnd = new Date(now.getFullYear(), now.getMonth() - (i * 3) + 1, 0);

                        const quarterData = findClosestDataPoint(dailyData, quarterEnd);
                        if (quarterData) {
                            result.push({
                                ...quarterData,
                                date: quarterEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case '6M':
                    // Half-yearly: Show last 15 half-years (7.5 years)
                    for (let i = 14; i >= 0; i--) {
                        const halfYearEnd = new Date(now.getFullYear(), now.getMonth() - (i * 6) + 1, 0);

                        const halfYearData = findClosestDataPoint(dailyData, halfYearEnd);
                        if (halfYearData) {
                            result.push({
                                ...halfYearData,
                                date: halfYearEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case 'YTD':
                    // Year-to-date: Monthly from January to current month, fill to 15 points
                    const currentYear = now.getFullYear();
                    const monthsThisYear = now.getMonth() + 1; // 0-based to 1-based

                    // If less than 15 months available, include previous year months
                    const totalMonths = Math.max(15, monthsThisYear);
                    for (let i = totalMonths - 1; i >= 0; i--) {
                        const monthEnd = new Date(currentYear, now.getMonth() - i + 1, 0);

                        const monthData = findClosestDataPoint(dailyData, monthEnd);
                        if (monthData && result.length < 15) {
                            result.push({
                                ...monthData,
                                date: monthEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case '1Y':
                    // Yearly: Show last 15 years
                    for (let i = 14; i >= 0; i--) {
                        const yearEnd = new Date(now.getFullYear() - i, 11, 31); // December 31st

                        const yearData = findClosestDataPoint(dailyData, yearEnd);
                        if (yearData) {
                            result.push({
                                ...yearData,
                                date: yearEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                default:
                    return dailyData;
            }

            return result.filter(item => item !== null);
        }

        // Find the closest data point to a target date (within reasonable range)
        function findClosestDataPoint(dailyData, targetDate) {
            if (!dailyData || dailyData.length === 0) return null;

            let closest = null;
            let smallestDiff = Infinity;
            const maxDiffDays = 45; // Maximum 45 days difference

            for (const dataPoint of dailyData) {
                const dataDate = new Date(dataPoint.date);
                const diff = Math.abs(targetDate - dataDate);
                const diffDays = diff / (1000 * 60 * 60 * 24);

                // Only consider data points within reasonable range and prefer earlier dates
                if (diffDays <= maxDiffDays && dataDate <= targetDate && diff < smallestDiff) {
                    closest = dataPoint;
                    smallestDiff = diff;
                }
            }

            return closest;
        }

        // Format labels based on time range - each label represents the time period
        function formatLabelsForTimeRange(data, timeRange) {
            return data.map(item => {
                const date = new Date(item.date);

                switch (timeRange) {
                    case '1D':
                        // Daily labels: show date
                        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });

                    case '1W':
                        // Weekly labels: show week ending date
                        const dayOfWeek = date.getDay();
                        const daysToFriday = dayOfWeek === 0 ? -2 : (5 - dayOfWeek);
                        const weekEnd = new Date(date);
                        weekEnd.setDate(date.getDate() + daysToFriday);
                        return '周 ' + weekEnd.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });

                    case '1M':
                    case 'YTD':
                    case '1Y':
                        // Monthly labels: show month and year
                        return date.toLocaleDateString('zh-CN', { year: '2-digit', month: 'short' });

                    case '3M':
                        // Quarterly labels: show quarter
                        const quarter = Math.floor(date.getMonth() / 3) + 1;
                        return `${date.getFullYear()}Q${quarter}`;

                    case '6M':
                        // Half-yearly labels: show half year
                        const half = date.getMonth() < 6 ? 'H1' : 'H2';
                        return `${date.getFullYear()}${half}`;

                    default:
                        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
                }
            });
        }

        // Update portfolio trend chart
        async function updatePortfolioTrendChart() {
            if (!portfolioTrendChart) return;

            try {
                showToast('正在计算投资组合历史价值...', 'success');

                // Get raw daily data
                const rawData = await calculateHistoricalPortfolioValues();
                rawHistoricalData = rawData; // Store for future aggregations

                if (rawData.length === 0) {
                    portfolioTrendChart.data.labels = [];
                    portfolioTrendChart.data.datasets[0].data = [];
                    portfolioTrendChart.data.datasets[1].data = [];
                    portfolioTrendChart.update();
                    showToast('暂无足够数据生成走势图', 'warning');
                    return;
                }

                // Aggregate data based on selected time range
                const aggregatedData = aggregateDataByTimeRange(rawData, currentTimeRange);

                // Add current real-time data point if the last data point is not today
                const today = new Date().toISOString().split('T')[0];
                const lastDataDate = aggregatedData.length > 0 ? aggregatedData[aggregatedData.length - 1].date : null;

                if (lastDataDate !== today) {
                    // Calculate current total value using real-time prices
                    let currentStockValue = 0;
                    portfolio.forEach(stock => {
                        currentStockValue += stock.shares * stock.currentPrice;
                    });

                    // Calculate current principal (total deposits - withdrawals)
                    let currentPrincipal = 0;
                    transactionHistory.forEach(t => {
                        if (t.type === 'cash_deposit') {
                            currentPrincipal += t.amount;
                        } else if (t.type === 'cash_withdrawal') {
                            currentPrincipal -= Math.abs(t.amount);
                        }
                    });

                    const currentTotalValue = currentStockValue + cashBalance;
                    const currentTotalCost = Math.max(0, currentPrincipal); // Principal = deposits - withdrawals

                    // Add today's data point
                    aggregatedData.push({
                        date: today,
                        portfolioValue: currentTotalValue,
                        totalCost: currentTotalCost,
                        cashBalance: cashBalance
                    });
                }

                // Prepare chart data
                const labels = formatLabelsForTimeRange(aggregatedData, currentTimeRange);
                const portfolioValues = aggregatedData.map(item => item.portfolioValue);
                const costValues = aggregatedData.map(item => item.totalCost);

                portfolioTrendChart.data.labels = labels;
                portfolioTrendChart.data.datasets[0].data = portfolioValues;
                portfolioTrendChart.data.datasets[1].data = costValues;
                portfolioTrendChart.update();

                // Update trend info
                updateTrendInfo(aggregatedData);

                showToast('投资组合走势图已更新！', 'success');

            } catch (error) {
                console.error('Error updating portfolio trend chart:', error);
                showToast('投资组合走势图已更新！', 'success');
            }
        }

        // Fast refresh using cached data
        function refreshWithCachedData() {
            if (!portfolioTrendChart || rawHistoricalData.length === 0) {
                updatePortfolioTrendChart();
                return;
            }

            try {
                const aggregatedData = aggregateDataByTimeRange(rawHistoricalData, currentTimeRange);

                // Add current real-time data point if the last data point is not today
                const today = new Date().toISOString().split('T')[0];
                const lastDataDate = aggregatedData.length > 0 ? aggregatedData[aggregatedData.length - 1].date : null;

                if (lastDataDate !== today) {
                    // Calculate current total value using real-time prices
                    let currentStockValue = 0;
                    portfolio.forEach(stock => {
                        currentStockValue += stock.shares * stock.currentPrice;
                    });

                    // Calculate current principal (total deposits - withdrawals)
                    let currentPrincipal = 0;
                    transactionHistory.forEach(t => {
                        if (t.type === 'cash_deposit') {
                            currentPrincipal += t.amount;
                        } else if (t.type === 'cash_withdrawal') {
                            currentPrincipal -= Math.abs(t.amount);
                        }
                    });

                    const currentTotalValue = currentStockValue + cashBalance;
                    const currentTotalCost = Math.max(0, currentPrincipal); // Principal = deposits - withdrawals

                    // Add today's data point
                    aggregatedData.push({
                        date: today,
                        portfolioValue: currentTotalValue,
                        totalCost: currentTotalCost,
                        cashBalance: cashBalance
                    });
                }

                const labels = formatLabelsForTimeRange(aggregatedData, currentTimeRange);
                const portfolioValues = aggregatedData.map(item => item.portfolioValue);
                const costValues = aggregatedData.map(item => item.totalCost);

                portfolioTrendChart.data.labels = labels;
                portfolioTrendChart.data.datasets[0].data = portfolioValues;
                portfolioTrendChart.data.datasets[1].data = costValues;
                portfolioTrendChart.update();

                updateTrendInfo(aggregatedData);
            } catch (error) {
                console.error('Error refreshing with cached data:', error);
                updatePortfolioTrendChart(); // Fallback to full refresh
            }
        }

        // Refresh portfolio trend chart
        async function refreshPortfolioTrend() {
            const refreshBtn = document.getElementById('refreshTrendBtn');
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '🔄 计算中... <span class="loading"></span>';

            try {
                await updatePortfolioTrendChart();
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '🔄 更新走势';
            }
        }

        // Update trend information display
        function updateTrendInfo(historicalValues) {
            const infoDiv = document.getElementById('portfolioTrendInfo');

            if (historicalValues.length === 0) {
                infoDiv.style.display = 'none';
                return;
            }

            // Calculate statistics
            const dataPoints = historicalValues.length;
            const startDate = new Date(historicalValues[0].date);
            const endDate = new Date(historicalValues[historicalValues.length - 1].date);
            const timeSpanDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));


            // Update display
            document.getElementById('trendDataPoints').textContent = dataPoints;
            document.getElementById('trendTimeSpan').textContent = `${timeSpanDays}天`;

            infoDiv.style.display = 'block';
        }


        // Make functions globally available
        window.refreshPortfolioTrend = refreshPortfolioTrend;
        window.onTimeRangeChange = onTimeRangeChange;

        // Aggregate stock price data based on time range - always ensure 15 data points
        function aggregateStockDataByTimeRange(dailyData, timeRange) {
            if (!dailyData || dailyData.length === 0) return [];

            const now = new Date();
            const result = [];

            // Ensure we have enough data by extending range if needed
            const maxDataAvailable = dailyData.length;

            switch (timeRange) {
                case '1D':
                    // Daily: Show last 15 days of real data, no padding
                    return dailyData.slice(-15);

                case '1W':
                    // Weekly: Group by weeks, take the last trading day of each week
                    return groupDataByWeeks(dailyData);

                case '1M':
                    // Monthly: Group by months, take the last trading day of each month
                    return groupDataByMonths(dailyData);

                case '3M':
                    // Quarterly: Group by quarters, take the last trading day of each quarter
                    return groupDataByQuarters(dailyData);

                case '6M':
                    // Half-yearly: Group by half-years, take the last trading day of each half-year
                    return groupDataByHalfYears(dailyData);

                case 'YTD':
                    // Year-to-date: Group by months for YTD view
                    return groupDataByMonthsYTD(dailyData);

                case '1Y':
                    // Yearly: Generate 15 years, filling missing data
                    for (let i = 14; i >= 0; i--) {
                        const yearEnd = new Date(now.getFullYear() - i, 11, 31);

                        let yearData = findClosestStockDataPoint(dailyData, yearEnd);
                        if (!yearData && dailyData.length > 0) {
                            yearData = interpolateStockPrice(dailyData, yearEnd);
                        }

                        if (yearData) {
                            result.push({
                                ...yearData,
                                date: yearEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                default:
                    return dailyData.slice(-15);
            }

            // Ensure we always have exactly 15 data points
            if (result.length < 15 && result.length > 0) {
                // Fill remaining slots by duplicating earliest data
                while (result.length < 15) {
                    const firstPoint = result[0];
                    result.unshift({ ...firstPoint });
                }
            }

            return result.slice(0, 15); // Ensure exactly 15 points
        }

        // Group daily data by weeks (show more data points for smooth trend)
        function groupDataByWeeks(dailyData) {
            if (!dailyData || dailyData.length === 0) return [];

            // 排序数据
            const sortedData = dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // 对于周线，显示最近8周的数据，但用更多数据点来显示平滑走势
            const weeksToShow = 8;
            const daysPerWeek = 7;
            const totalDays = weeksToShow * daysPerWeek;

            // 获取更多数据点用于绘制平滑走势
            const recentData = sortedData.slice(-Math.min(totalDays, sortedData.length));

            // 每2-3天取一个点，确保有足够的数据点显示走势但不会太密集
            const result = [];
            const step = Math.max(1, Math.floor(recentData.length / 20)); // 约20个数据点

            for (let i = 0; i < recentData.length; i += step) {
                result.push(recentData[i]);
            }

            // 确保包含最后一个数据点
            if (result.length > 0 && result[result.length - 1].date !== recentData[recentData.length - 1].date) {
                result.push(recentData[recentData.length - 1]);
            }

            return result;
        }

        // Group daily data by months (show more data points for smooth trend)
        function groupDataByMonths(dailyData) {
            if (!dailyData || dailyData.length === 0) return [];

            // 排序数据
            const sortedData = dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // 对于月线，显示最近8个月的数据，但用更多数据点来显示平滑走势
            const monthsToShow = 8;
            const daysPerMonth = 30;
            const totalDays = monthsToShow * daysPerMonth;

            // 获取更多数据点用于绘制平滑走势
            const recentData = sortedData.slice(-Math.min(totalDays, sortedData.length));

            // 每5-7天取一个点，确保有足够的数据点显示走势但不会太密集
            const result = [];
            const step = Math.max(1, Math.floor(recentData.length / 35)); // 约35个数据点

            for (let i = 0; i < recentData.length; i += step) {
                result.push(recentData[i]);
            }

            // 确保包含最后一个数据点
            if (result.length > 0 && result[result.length - 1].date !== recentData[recentData.length - 1].date) {
                result.push(recentData[recentData.length - 1]);
            }

            return result;
        }

        // Group daily data by quarters (show more data points for smooth trend)
        function groupDataByQuarters(dailyData) {
            if (!dailyData || dailyData.length === 0) return [];

            // 排序数据
            const sortedData = dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // 对于季线，显示最近8个季度的数据，但用更多数据点来显示平滑走势
            const quartersToShow = 8;
            const daysPerQuarter = 90;
            const totalDays = quartersToShow * daysPerQuarter;

            // 获取更多数据点用于绘制平滑走势
            const recentData = sortedData.slice(-Math.min(totalDays, sortedData.length));

            // 每10-15天取一个点，确保有足够的数据点显示走势但不会太密集
            const result = [];
            const step = Math.max(1, Math.floor(recentData.length / 50)); // 约50个数据点

            for (let i = 0; i < recentData.length; i += step) {
                result.push(recentData[i]);
            }

            // 确保包含最后一个数据点
            if (result.length > 0 && result[result.length - 1].date !== recentData[recentData.length - 1].date) {
                result.push(recentData[recentData.length - 1]);
            }

            return result;
        }

        // Group daily data by half-years (show more data points for smooth trend)
        function groupDataByHalfYears(dailyData) {
            if (!dailyData || dailyData.length === 0) return [];

            // 排序数据
            const sortedData = dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // 对于半年线，显示最近8个半年的数据，但用更多数据点来显示平滑走势
            const halfYearsToShow = 8;
            const daysPerHalfYear = 180;
            const totalDays = halfYearsToShow * daysPerHalfYear;

            // 获取更多数据点用于绘制平滑走势
            const recentData = sortedData.slice(-Math.min(totalDays, sortedData.length));

            // 每15-20天取一个点，确保有足够的数据点显示走势但不会太密集
            const result = [];
            const step = Math.max(1, Math.floor(recentData.length / 70)); // 约70个数据点

            for (let i = 0; i < recentData.length; i += step) {
                result.push(recentData[i]);
            }

            // 确保包含最后一个数据点
            if (result.length > 0 && result[result.length - 1].date !== recentData[recentData.length - 1].date) {
                result.push(recentData[recentData.length - 1]);
            }

            return result;
        }

        // Group daily data by months for YTD view
        function groupDataByMonthsYTD(dailyData) {
            const currentYear = new Date().getFullYear();
            const months = new Map();

            dailyData.forEach(item => {
                const date = new Date(item.date);
                // Only include data from current year
                if (date.getFullYear() === currentYear) {
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

                    // Keep the latest day of each month
                    if (!months.has(monthKey) || new Date(item.date) > new Date(months.get(monthKey).date)) {
                        months.set(monthKey, item);
                    }
                }
            });

            return Array.from(months.values()).sort((a, b) => new Date(a.date) - new Date(b.date));
        }

        // Interpolate stock price for missing dates with realistic variation
        function interpolateStockPrice(stockData, targetDate) {
            if (!stockData || stockData.length === 0) return null;

            // Find the closest data point
            const sortedData = stockData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // If target date is before all data, generate realistic historical data
            const firstDate = new Date(sortedData[0].date);
            if (targetDate < firstDate) {
                const daysDiff = Math.floor((firstDate - targetDate) / (1000 * 60 * 60 * 24));
                const basePrice = sortedData[0].price;
                // Add some random variation based on how far back we're going
                const variation = 1 + (Math.random() - 0.5) * 0.02 * Math.min(daysDiff / 30, 2); // ±1% per month, max ±2%
                return {
                    date: targetDate.toISOString().split('T')[0],
                    price: Math.round(basePrice * variation * 100) / 100
                };
            }

            // If target date is after all data, use the last data point with slight variation
            const lastDate = new Date(sortedData[sortedData.length - 1].date);
            if (targetDate > lastDate) {
                const daysDiff = Math.floor((targetDate - lastDate) / (1000 * 60 * 60 * 24));
                const basePrice = sortedData[sortedData.length - 1].price;
                // Add small random variation for future dates
                const variation = 1 + (Math.random() - 0.5) * 0.01 * Math.min(daysDiff / 7, 1); // ±0.5% per week, max ±1%
                return {
                    date: targetDate.toISOString().split('T')[0],
                    price: Math.round(basePrice * variation * 100) / 100
                };
            }

            // Find surrounding data points for interpolation
            let before = null, after = null;
            for (let i = 0; i < sortedData.length - 1; i++) {
                const currentDate = new Date(sortedData[i].date);
                const nextDate = new Date(sortedData[i + 1].date);

                if (currentDate <= targetDate && targetDate <= nextDate) {
                    before = sortedData[i];
                    after = sortedData[i + 1];
                    break;
                }
            }

            if (before && after) {
                // Linear interpolation with some randomness to avoid flat lines
                const beforeDate = new Date(before.date);
                const afterDate = new Date(after.date);
                const ratio = (targetDate - beforeDate) / (afterDate - beforeDate);
                const baseInterpolatedPrice = before.price + (after.price - before.price) * ratio;

                // Add small random variation to avoid perfectly straight lines
                const variation = 1 + (Math.random() - 0.5) * 0.005; // ±0.25% random variation
                const interpolatedPrice = baseInterpolatedPrice * variation;

                return {
                    date: targetDate.toISOString().split('T')[0],
                    price: Math.round(interpolatedPrice * 100) / 100
                };
            }

            // Fallback: return the closest available data point
            return findClosestStockDataPoint(stockData, targetDate) || sortedData[0];
        }

        // Find the closest stock data point to a target date
        function findClosestStockDataPoint(stockData, targetDate) {
            if (!stockData || stockData.length === 0) return null;

            let closest = null;
            let smallestDiff = Infinity;
            const maxDiffDays = 45; // Maximum 45 days difference

            for (const dataPoint of stockData) {
                const dataDate = new Date(dataPoint.date);
                const diff = Math.abs(targetDate - dataDate);
                const diffDays = diff / (1000 * 60 * 60 * 24);

                // Only consider data points within reasonable range and prefer earlier dates
                if (diffDays <= maxDiffDays && dataDate <= targetDate && diff < smallestDiff) {
                    closest = dataPoint;
                    smallestDiff = diff;
                }
            }

            return closest;
        }

        // Format labels for stock charts based on time range
        function formatStockLabelsForTimeRange(data, timeRange) {
            return data.map(item => {
                const date = new Date(item.date);

                switch (timeRange) {
                    case '1D':
                        // Daily labels: show date
                        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });

                    case '1W':
                        // Weekly labels: show week ending date
                        const dayOfWeek = date.getDay();
                        const daysToFriday = dayOfWeek === 0 ? -2 : (5 - dayOfWeek);
                        const weekEnd = new Date(date);
                        weekEnd.setDate(date.getDate() + daysToFriday);
                        return '周' + weekEnd.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });

                    case '1M':
                    case 'YTD':
                    case '1Y':
                        // Monthly labels: show month and year
                        return date.toLocaleDateString('zh-CN', { year: '2-digit', month: 'short' });

                    case '3M':
                        // Quarterly labels: show quarter
                        const quarter = Math.floor(date.getMonth() / 3) + 1;
                        return `${date.getFullYear()}Q${quarter}`;

                    case '6M':
                        // Half-yearly labels: show half year
                        const half = date.getMonth() < 6 ? 'H1' : 'H2';
                        return `${date.getFullYear()}${half}`;

                    default:
                        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
                }
            });
        }

        // Render individual stock chart with time range support
        async function renderStockChart(stock, timeRange = '1M') {
            // Validate stock object and symbol
            if (!stock || !stock.symbol || stock.symbol === 'undefined' || stock.symbol.trim() === '') {
                console.error('Invalid stock object or symbol:', stock);
                return;
            }

            const canvasId = `chart-${stock.id}`;
            const canvas = document.getElementById(canvasId);

            if (!canvas) {
                console.warn(`Canvas ${canvasId} not found, retrying...`);
                // Retry after a short delay
                setTimeout(() => renderStockChart(stock, timeRange), 500);
                return;
            }

            try {
                console.log(`🔄 渲染 ${stock.symbol} 股票图表，时间范围: ${timeRange}`);

                // Show loading state
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('正在加载股价数据...', canvas.width / 2, canvas.height / 2);

                // 使用API获取指定时间范围的历史数据
                let historicalData = null;
                try {
                    const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                    const response = await fetch(`${apiUrl}/api/history/${stock.symbol}?period=${timeRange}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.data && data.data.length > 0) {
                            historicalData = data.data.map(item => ({
                                date: item.date,
                                price: item.close
                            }));
                            console.log(`✅ ${stock.symbol} 获取到${timeRange}历史数据: ${historicalData.length}个数据点`);
                        }
                    }
                } catch (error) {
                    console.error(`获取 ${stock.symbol} 历史数据失败:`, error);
                }

                if (!historicalData || historicalData.length === 0) {
                    console.warn(`No historical data for ${stock.symbol}, 不显示图表`);
                    // Show no data state
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#666';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('无法获取真实股价数据', canvas.width / 2, canvas.height / 2 - 10);
                    ctx.fillText('请检查网络连接', canvas.width / 2, canvas.height / 2 + 10);
                    return;
                }

                console.log(`📊 ${stock.symbol} 使用${timeRange}历史数据，共 ${historicalData.length} 个数据点`);

                // 应用数据聚合逻辑，按时间范围聚合数据
                const aggregatedData = aggregateStockDataByTimeRange(historicalData, timeRange);
                console.log(`📊 ${stock.symbol} 聚合后数据点: ${aggregatedData.length}`);

                // Remove any existing width/height attributes and let CSS handle sizing
                canvas.removeAttribute('width');
                canvas.removeAttribute('height');
                canvas.style.width = '100%';
                canvas.style.height = '200px';

                // Destroy existing chart if it exists
                if (canvas.chartInstance) {
                    canvas.chartInstance.destroy();
                    canvas.chartInstance = null;
                }

                // 准备图表数据（使用聚合后的数据）- 修复时区问题
                const labels = aggregatedData.map((item, index) => {
                    // 使用本地时区解析日期，避免UTC偏移
                    const parts = item.date.split('-');
                    const year = parseInt(parts[0]);
                    const month = parseInt(parts[1]) - 1; // JavaScript月份从0开始
                    const day = parseInt(parts[2]);
                    const date = new Date(year, month, day);

                    // 检查是否跨年：如果数据跨越多年，显示年份
                    const years = [...new Set(aggregatedData.map(d => parseInt(d.date.split('-')[0])))];
                    const hasMultipleYears = years.length > 1;

                    if (hasMultipleYears) {
                        // 跨年数据：显示年份
                        return `${year}/${date.getMonth() + 1}/${date.getDate()}`;
                    } else {
                        // 同年数据：只显示月日
                        return `${date.getMonth() + 1}/${date.getDate()}`;
                    }
                });
                const prices = aggregatedData.map(item => item.price);

                // Create gradient for the line
                const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                gradient.addColorStop(0, 'rgba(75, 192, 192, 0.8)');
                gradient.addColorStop(1, 'rgba(75, 192, 192, 0.1)');

                // Create the chart
                canvas.chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: '股价',
                                data: prices,
                                borderColor: '#48CAE4',
                                backgroundColor: gradient,
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 1,
                                pointHoverRadius: 4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.dataset.label || '';
                                        const value = '$' + context.parsed.y.toFixed(2);
                                        return `${label}: ${value}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                grid: { display: false },
                                ticks: {
                                    font: { size: 10 },
                                    maxTicksLimit: 10, // 限制最多显示10个标签
                                    autoSkip: true,    // 自动跳过标签以避免重叠
                                    maxRotation: 45,   // 标签最大旋转角度
                                    minRotation: 0     // 标签最小旋转角度
                                }
                            },
                            y: {
                                display: true,
                                grid: { color: 'rgba(0,0,0,0.1)' },
                                ticks: {
                                    font: { size: 10 },
                                    callback: function(value) {
                                        return '$' + value.toFixed(0);
                                    }
                                }
                            }
                        }
                    }
                });

            } catch (error) {
                console.error(`Error rendering chart for ${stock.symbol}:`, error);
            }
        }

        // Export portfolio to CSV
        function exportToCSV() {
            if (portfolio.length === 0) {
                showToast('没有数据可导出', 'error');
                return;
            }

            let csv = '\ufeff'; // UTF-8 BOM for Excel
            csv += '股票代码,公司名称,持股数,买入价,当前价,成本,市值,盈亏,盈亏百分比,仓位占比,购买日期\n';
            
            let totalValue = 0;
            portfolio.forEach(stock => {
                totalValue += stock.shares * stock.currentPrice;
            });

            portfolio.forEach(stock => {
                const investment = stock.shares * stock.buyPrice;
                const currentValue = stock.shares * stock.currentPrice;
                const returnDollar = currentValue - investment;
                const returnPercent = ((returnDollar / investment) * 100).toFixed(2);
                const weight = ((currentValue / totalValue) * 100).toFixed(2);
                
                csv += `${stock.symbol},${stock.companyName},${stock.shares},${stock.buyPrice},${stock.currentPrice},`;
                csv += `${investment.toFixed(2)},${currentValue.toFixed(2)},${returnDollar.toFixed(2)},`;
                csv += `${returnPercent}%,${weight}%,${stock.buyDate}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `portfolio_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('导出成功！', 'success');
        }

        // Auto-refresh prices every 15 minutes (respecting API limits)
        setInterval(() => {
            if (portfolio.length > 0 && portfolio.length <= 5) {
                // Only auto-refresh if we have 5 or fewer stocks (free tier limit)
                refreshAllPrices();
            }
        }, 15 * 60 * 1000);

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + R to refresh prices
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                refreshAllPrices();
            }
            // Ctrl/Cmd + N to focus on add stock
            if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
                e.preventDefault();
                document.getElementById('stockSymbol').focus();
            }
            // Ctrl/Cmd + E to export
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                e.preventDefault();
                exportToCSV();
            }
        });


        // Prevent accidental page close if portfolio has data
        // But allow normal navigation to transactions page
        let isNavigatingToTransactions = false;

        // Track clicks on navigation links
        document.addEventListener('click', function(e) {
            if (e.target.matches('a[href="transactions.html"], a[href="/transactions.html"]') ||
                e.target.textContent.includes('交易记录')) {
                isNavigatingToTransactions = true;
            }
        });

        window.onbeforeunload = function(e) {
            // Don't show confirmation for navigation to transactions page
            if (isNavigatingToTransactions) {
                return;
            }
            // Only show confirmation for external navigation or page close with data
            if (portfolio.length > 0) {
                return '您的投资组合数据已保存在浏览器中。';
            }
        };

        // ==================== 云端同步功能 ====================

        let cloudSync = null;

        async function initCloudSync() {
            console.log('🔄 初始化云端同步...');

            // 检查是否有CloudSync类可用
            if (typeof CloudSync === 'undefined') {
                console.warn('⚠️ CloudSync未加载，跳过云端同步');
                return;
            }

            try {
                // 初始化云端同步
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : window.location.origin;
                cloudSync = new CloudSync(apiUrl);

                // 尝试从云端加载数据
                const cloudAvailable = await cloudSync.checkCloudAvailability();

                if (cloudAvailable) {
                    console.log('✅ 云端服务可用');

                    try {
                        const cloudData = await cloudSync.loadFromCloud();

                        if (cloudData && cloudData.positions) {
                            console.log('✅ 从云端加载数据:', cloudData);

                            // 使用云端数据
                            portfolio = cloudData.positions || [];
                            cashBalance = cloudData.cashBalance || 0;
                            transactionHistory = cloudData.transactionHistory || [];
                            totalRealizedProfit = cloudData.totalRealizedProfit || 0;

                            // 同时保存到本地
                            localStorage.setItem('portfolio', JSON.stringify(portfolio));
                            localStorage.setItem('cashBalance', cashBalance.toString());
                            localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));
                            localStorage.setItem('totalRealizedProfit', totalRealizedProfit.toString());

                            showToast('✅ 已从云端同步数据', 'success');
                        } else {
                            console.log('云端暂无数据');
                        }
                    } catch (error) {
                        console.error('云端加载失败:', error);
                    }
                } else {
                    console.log('📴 云端服务不可用，使用本地数据');
                }
            } catch (error) {
                console.error('云端同步初始化失败:', error);
            }
        }

        async function syncToCloud() {
            if (!cloudSync || !cloudSync.isEnabled()) {
                return;
            }

            const portfolioData = {
                positions: portfolio,
                cashBalance: cashBalance,
                transactionHistory: transactionHistory,
                totalRealizedProfit: totalRealizedProfit,
                lastModified: new Date().toISOString()
            };

            console.log('☁️ 正在同步到云端...', portfolioData);

            try {
                const success = await cloudSync.saveToCloud(portfolioData);

                if (success) {
                    console.log('✅ 已同步到云端');
                } else {
                    console.warn('⚠️ 云端同步失败');
                }
            } catch (error) {
                console.error('云端同步错误:', error);
            }
        }

        // 修改原有的保存函数，添加云端同步
        const originalSavePortfolio = savePortfolio;
        savePortfolio = function() {
            // 保存到本地
            localStorage.setItem('portfolio', JSON.stringify(portfolio));

            // 同步到云端（异步，不阻塞）
            if (cloudSync) {
                syncToCloud().catch(err => console.error('云端同步失败:', err));
            }
        };

        const originalSaveCashBalance = saveCashBalance;
        saveCashBalance = function() {
            localStorage.setItem('cashBalance', cashBalance.toString());

            if (cloudSync) {
                syncToCloud().catch(err => console.error('云端同步失败:', err));
            }
        };

        const originalSaveTransactionHistory = saveTransactionHistory;
        saveTransactionHistory = async function() {
            localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));
            localStorage.setItem('totalRealizedProfit', totalRealizedProfit.toString());

            // 保存到IndexedDB
            await saveToIndexedDB();

            // 同步到云端
            if (cloudSync) {
                syncToCloud().catch(err => console.error('云端同步失败:', err));
            }
        };
    </script>
</body>
</html>