<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‚¡ç¥¨æŠ•èµ„ç»„åˆè¿½è¸ªå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- é…ç½®å’Œäº‘ç«¯åŒæ­¥ -->
    <script src="config.js"></script>
    <script src="cloud-sync.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Microsoft YaHei', 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            min-height: 100vh;
            padding: 20px;
            color: #1a202c;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 12px;
            padding: 32px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
            position: relative;
            background: #ffffff;
            color: #1a202c;
            padding: 24px;
            border-radius: 8px;
            border-bottom: 1px solid #e2e8f0;
        }

        .header-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        .nav-link {
            color: #4a5568;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .nav-link:hover {
            background: #f7fafc;
            color: #2d3748;
        }

        .nav-link.active {
            background: #2b6cb0;
            color: white;
            font-weight: 600;
        }

        h1 {
            color: #1a202c;
            font-size: 2.4em;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            letter-spacing: -0.025em;
        }

        .last-update {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
            margin-top: 10px;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }

        .summary-card {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .summary-card h3 {
            color: #666;
            font-size: 0.95em;
            margin-bottom: 12px;
            font-weight: 500;
        }

        .summary-card p {
            font-size: 2em;
            font-weight: bold;
            color: #1e3c72;
        }

        .summary-card.profit p {
            color: #10b981;
        }

        .summary-card.loss p {
            color: #ef4444;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        .add-stock-section {
            background: #667eea;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .add-stock-section h2 {
            color: white;
            margin-bottom: 25px;
            font-size: 1.6em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cash-management-section {
            background: #28a745;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .cash-management-section h2 {
            color: white;
            margin-bottom: 25px;
            font-size: 1.6em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chart-section {
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .chart-section h2 {
            color: #1e3c72;
            margin-bottom: 20px;
            font-size: 1.6em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .input-wrapper {
            display: flex;
            flex-direction: column;
        }

        label {
            color: white;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 1em;
        }

        input {
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            background: rgba(255, 255, 255, 0.95);
            transition: all 0.3s;
        }

        input:focus {
            outline: none;
            background: white;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        button {
            background: #ffffff;
            color: #4a5568;
            border: 1px solid #e2e8f0;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            background: #f7fafc;
            border-color: #cbd5e0;
            color: #2d3748;
        }

        .refresh-btn {
            background: #ffffff;
            color: #374151;
            border: 1px solid #d1d5db;
        }

        .refresh-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .export-btn {
            background: #3b82f6;
            color: white;
            margin-left: 10px;
            border: none;
        }

        .export-btn:hover {
            background: #2563eb;
        }

        .portfolio-table {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            margin-bottom: 30px;
        }

        .table-header {
            background: #1e3c72;
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-header h2 {
            font-size: 1.6em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-actions {
            display: flex;
            gap: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: #f8f9fa;
            color: #1e3c72;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            font-size: 0.95em;
            border-bottom: 2px solid #e9ecef;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid #f1f3f5;
            font-size: 0.95em;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .stock-symbol {
            font-weight: bold;
            color: #1e3c72;
            font-size: 1.1em;
        }

        .positive {
            color: #10b981;
            font-weight: 600;
        }

        .negative {
            color: #ef4444;
            font-weight: 600;
        }

        .neutral {
            color: #6b7280;
            font-weight: 600;
        }

        .action-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .buy-more-btn, .sell-part-btn, .delete-btn {
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .buy-more-btn {
            background: #28a745;
            color: white;
        }

        .buy-more-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .sell-part-btn {
            background: #ffc107;
            color: #212529;
        }

        .sell-part-btn:hover {
            background: #e0a800;
            transform: translateY(-1px);
        }

        .delete-btn {
            background: #dc3545;
            color: white;
        }

        .delete-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #999;
        }

        .empty-state h3 {
            font-size: 1.8em;
            margin-bottom: 15px;
            color: #666;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: white;
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 400px;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            border-left: 5px solid #10b981;
        }

        .toast.error {
            border-left: 5px solid #ef4444;
        }

        .toast.warning {
            border-left: 5px solid #f59e0b;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            padding: 20px 25px;
            background: #ffffff;
            color: #1f2937;
            border-bottom: 1px solid #e5e7eb;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.4em;
        }

        .modal-close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .modal-body {
            padding: 20px 25px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .stock-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .stock-info h4 {
            margin: 0;
            color: #495057;
            font-size: 1.1em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.2s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .input-hint {
            display: block;
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
        }

        .calculated-amount, .calculated-profit {
            padding: 12px;
            background: #e9ecef;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: 600;
        }

        .calculated-profit.positive {
            background: #d4edda;
            color: #155724;
        }

        .calculated-profit.negative {
            background: #f8d7da;
            color: #721c24;
        }

        .modal-footer {
            padding: 20px 25px;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            background: white;
            border-radius: 0 0 15px 15px;
            position: sticky;
            bottom: 0;
            margin-top: auto;
        }

        .modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cancel-btn {
            background: #6c757d;
            color: white;
        }

        .cancel-btn:hover {
            background: #5a6268;
        }

        .confirm-btn {
            background: #28a745;
            color: white;
        }

        .confirm-btn:hover {
            background: #218838;
        }

        .confirm-btn.sell {
            background: #ffc107;
            color: #212529;
        }

        .confirm-btn.sell:hover {
            background: #e0a800;
        }

        .confirm-btn.delete {
            background: #dc3545;
        }

        .confirm-btn.delete:hover {
            background: #c82333;
        }

        .stock-chart-row {
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }

        .stock-chart-container {
            padding: 20px;
            margin: 10px 0;
            width: 100%;
            overflow: hidden;
        }

        .stock-chart-container h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 14px;
            font-weight: 600;
        }

        .stock-chart-container canvas {
            max-width: 100% !important;
            width: 100% !important;
            height: 200px !important;
            border-radius: 6px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: block;
        }

        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 200px;
        }

        .stock-detail-header {
            padding: 15px 20px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background-color 0.2s ease;
        }

        .stock-detail-header:hover {
            background: #dee2e6;
        }

        .detail-toggle-icon {
            font-size: 14px;
            transition: transform 0.2s ease;
            color: #007bff;
            font-weight: bold;
        }

        .detail-toggle-icon.expanded {
            transform: rotate(-90deg);
        }

        .detail-title {
            font-weight: 600;
            color: #495057;
            font-size: 15px;
        }

        .detail-subtitle {
            font-size: 12px;
            color: #6c757d;
            margin-left: auto;
        }

        .stock-detail-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 20px;
            background: #f8f9fa;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 1000px;
            }
        }

        .loading-data {
            color: #6c757d;
            font-style: italic;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .stock-specs h4 {
            margin: 0 0 20px 0;
            color: #495057;
            font-size: 16px;
            font-weight: 600;
            border-bottom: 2px solid #007bff;
            padding-bottom: 8px;
        }

        .specs-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .spec-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .spec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .spec-item:last-child {
            border-bottom: none;
        }

        .spec-label {
            font-size: 13px;
            color: #6c757d;
            font-weight: 500;
        }

        .spec-value {
            font-size: 13px;
            color: #495057;
            font-weight: 600;
            text-align: right;
        }

        @media (max-width: 1200px) {
            .stock-detail-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .specs-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 1366px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .summary-cards {
                grid-template-columns: 1fr 1fr;
            }
            
            table {
                font-size: 0.85em;
            }
            
            th, td {
                padding: 10px 8px;
            }

            .button-group {
                grid-template-columns: 1fr;
            }

            .table-actions {
                flex-direction: column;
            }
        }

        /* Robinhood-style Time Selector */
        .time-selector {
            display: flex;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 2px;
            gap: 2px;
            backdrop-filter: blur(10px);
        }

        .time-selector.dark {
            background: rgba(255, 255, 255, 0.1);
        }

        .time-selector.light {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .time-btn {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 500;
            color: #6b7280;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 36px;
            text-align: center;
        }

        .time-btn:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            color: #374151;
        }

        .time-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
            font-weight: 600;
        }

        .time-selector-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .time-selector-label {
            color: white;
            font-size: 0.9em;
            font-weight: 500;
        }

        .time-selector-label.light {
            color: #333;
        }

        /* éšè—æ•°å­—è¾“å…¥æ¡†çš„ä¸Šä¸‹ç®­å¤´ */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Firefox */
        input[type="number"] {
            -moz-appearance: textfield;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                ğŸ“Š è‚¡ç¥¨æŠ•èµ„ç»„åˆè¿½è¸ªå™¨
            </h1>
            <div class="header-nav">
                <div class="nav-links">
                    <a href="/" class="nav-link active">ğŸ“ˆ æŠ•èµ„ç»„åˆ</a>
                    <a href="transactions.html" class="nav-link">ğŸ“‹ äº¤æ˜“è®°å½•</a>
                </div>
                <div class="last-update">
                    æœ€åæ›´æ–°: <span id="lastUpdate">-</span>
                </div>
            </div>
        </div>
        
        <div class="summary-cards">
            <div class="summary-card">
                <h3>ğŸ’µ ç°é‡‘ä½™é¢</h3>
                <p id="cashBalance">$0.00</p>
            </div>
            <div class="summary-card">
                <h3>ğŸ’ å½“å‰å¸‚å€¼</h3>
                <p id="currentValue">$0.00</p>
            </div>
            <div class="summary-card" id="totalReturnCard">
                <h3>ğŸ“ˆ æµ®ç›ˆæ”¶ç›Š</h3>
                <p id="totalReturn">$0.00</p>
            </div>
            <div class="summary-card">
                <h3>ğŸ“ æŒä»“æ•°é‡</h3>
                <p id="stockCount">0</p>
            </div>
            <div class="summary-card">
                <h3>ğŸ’¸ æ€»æ‰‹ç»­è´¹</h3>
                <p id="totalFees">$0.00</p>
            </div>
            <div class="summary-card">
                <h3>ğŸ’° æœ¬é‡‘</h3>
                <p id="totalInvestment">$0.00</p>
            </div>
        </div>

        <div class="main-content">
            <div class="cash-management-section">
                <h2>ğŸ’° èµ„é‡‘ç®¡ç†</h2>
                <div class="input-group">
                    <div class="input-wrapper">
                        <label for="cashAmount">é‡‘é¢ï¼ˆç¾å…ƒï¼‰</label>
                        <input type="number" id="cashAmount" placeholder="1000.00" step="0.01" required>
                    </div>
                    <div class="input-wrapper">
                        <label for="cashDate">äº¤æ˜“æ—¥æœŸ</label>
                        <input type="date" id="cashDate" required>
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="depositCash()">ğŸ’µ è½¬å…¥èµ„é‡‘</button>
                    <button onclick="withdrawCash()">ğŸ’¸ è½¬å‡ºèµ„é‡‘</button>
                </div>
                <div style="margin-top: 20px; color: white; font-size: 0.9em;">
                    <p>ğŸ’¡ å½“å‰ç°é‡‘ä½™é¢: $<span id="currentCashDisplay">0.00</span></p>
                </div>
            </div>
            <div class="add-stock-section">
                <h2>â• æ·»åŠ æ–°äº¤æ˜“</h2>
                <div class="input-group">
                    <div class="input-wrapper">
                        <label for="stockSymbol">è‚¡ç¥¨ä»£ç ï¼ˆå¦‚ï¼šAAPLã€MSFTï¼‰</label>
                        <input type="text" id="stockSymbol" placeholder="è¾“å…¥ç¾è‚¡ä»£ç " required>
                    </div>
                    <div class="input-wrapper">
                        <label for="shares">è´­ä¹°è‚¡æ•°</label>
                        <input type="number" id="shares" placeholder="10" step="0.01" required>
                    </div>
                    <div class="input-wrapper">
                        <label for="buyPrice">ä¹°å…¥ä»·æ ¼ï¼ˆæ¯è‚¡ç¾å…ƒï¼‰</label>
                        <input type="number" id="buyPrice" placeholder="150.00" step="0.01" required>
                    </div>
                    <div class="input-wrapper">
                        <label for="initialFee">æ‰‹ç»­è´¹ï¼ˆæ¯è‚¡ç¾å…ƒï¼‰</label>
                        <input type="number" id="initialFee" placeholder="0.02" step="0.001" min="0" value="0.02">
                    </div>
                    <div class="input-wrapper">
                        <label for="buyDate">è´­ä¹°æ—¥æœŸ</label>
                        <input type="date" id="buyDate" required>
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="addStock()">ğŸ“¥ æ·»åŠ åˆ°ç»„åˆ</button>
                    <button onclick="quickFillDemo()">ğŸ¯ å¿«é€Ÿç¤ºä¾‹</button>
                </div>
            </div>
            <div class="chart-section">
                <h2>ğŸ¥§ æŒä»“åˆ†å¸ƒå›¾</h2>
                <div class="chart-container">
                    <canvas id="portfolioChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Portfolio Value Trend Chart Section -->
        <div class="portfolio-table" style="margin-bottom: 30px;">
            <div class="table-header">
                <h2>ğŸ“ˆ èµ„äº§èµ°åŠ¿å›¾</h2>
                <div class="table-actions" style="display: flex; align-items: center; gap: 15px;">
                    <div class="time-selector-container">
                        <span class="time-selector-label">æ—¶é—´èŒƒå›´:</span>
                        <div class="time-selector dark" id="portfolioTimeSelector">
                            <button class="time-btn active" data-period="1D" onclick="selectTimeRange('1D')">æ—¥çº¿</button>
                            <button class="time-btn" data-period="1W" onclick="selectTimeRange('1W')">å‘¨çº¿</button>
                            <button class="time-btn" data-period="1M" onclick="selectTimeRange('1M')">æœˆçº¿</button>
                            <button class="time-btn" data-period="3M" onclick="selectTimeRange('3M')">å­£çº¿</button>
                            <button class="time-btn" data-period="6M" onclick="selectTimeRange('6M')">åŠå¹´çº¿</button>
                            <button class="time-btn" data-period="YTD" onclick="selectTimeRange('YTD')">ä»Šå¹´</button>
                        </div>
                    </div>
                    <button class="refresh-btn" onclick="refreshPortfolioTrend()" id="refreshTrendBtn">
                        ğŸ”„ æ›´æ–°èµ°åŠ¿
                    </button>
                </div>
            </div>
            <div style="padding: 30px; background: white;">
                <div class="chart-container" style="height: 400px;">
                    <canvas id="portfolioTrendChart"></canvas>
                </div>
            </div>
            </div>
        </div>

        <div class="portfolio-table">
            <div class="table-header">
                <h2>ğŸ“‹ æˆ‘çš„æŒä»“æ˜ç»†</h2>
                <div class="table-actions">
                    <button class="refresh-btn" onclick="refreshAllPrices()" id="refreshBtn">
                        ğŸ”„ åˆ·æ–°æ‰€æœ‰ä»·æ ¼
                    </button>
                </div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th>è‚¡ç¥¨ä»£ç </th>
                        <th>å…¬å¸åç§°</th>
                        <th>æŒè‚¡æ•°</th>
                        <th>ä¹°å…¥ä»·</th>
                        <th>å½“å‰ä»·</th>
                        <th>æˆæœ¬</th>
                        <th>å¸‚å€¼</th>
                        <th>ç›ˆäº($)</th>
                        <th>ç›ˆäº(%)</th>
                        <th>ä»“ä½å æ¯”</th>
                        <th>æŒæœ‰å¤©æ•°</th>
                        <th>æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="portfolioBody">
                    <tr class="empty-state">
                        <td colspan="12">
                            <h3>ğŸ“­ æš‚æ— æŒä»“</h3>
                            <p>ä½¿ç”¨ä¸Šæ–¹è¡¨å•æ·»åŠ æ‚¨çš„ç¬¬ä¸€æ”¯è‚¡ç¥¨</p>
                            <p style="margin-top: 10px; color: #666;">æ”¯æŒç¾è‚¡å®æ—¶ä»·æ ¼è‡ªåŠ¨æ›´æ–°</p>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Trading Modal -->
    <div id="tradingModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">äº¤æ˜“æ“ä½œ</h3>
                <span class="modal-close" onclick="closeTradingModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="stock-info">
                    <h4 id="modalStockInfo">è‚¡ç¥¨ä¿¡æ¯</h4>
                </div>
                <form id="tradingForm">
                    <div class="form-group">
                        <label for="modalShares">è‚¡æ•°:</label>
                        <input type="number" id="modalShares" step="0.01" min="0" required>
                        <span class="input-hint" id="sharesHint"></span>
                    </div>
                    <div class="form-group">
                        <label for="modalPrice">ä»·æ ¼:</label>
                        <input type="number" id="modalPrice" step="0.01" min="0" required>
                        <span class="input-hint" id="priceHint"></span>
                    </div>
                    <div class="form-group">
                        <label for="modalFee">æ‰‹ç»­è´¹ (æ¯è‚¡):</label>
                        <input type="number" id="modalFee" step="0.001" min="0" value="0.02" placeholder="0.02">
                        <span class="input-hint">é€šå¸¸ä¸º $0.005-$0.01 æ¯è‚¡</span>
                    </div>
                    <div class="form-group">
                        <label>é¢„è®¡é‡‘é¢:</label>
                        <div class="calculated-amount" id="calculatedAmount">$0.00</div>
                    </div>
                    <div class="form-group">
                        <label>æ€»æ‰‹ç»­è´¹:</label>
                        <div class="calculated-fee" id="calculatedFee">$0.00</div>
                    </div>
                    <div class="form-group" id="profitInfo" style="display: none;">
                        <label>é¢„è®¡ç›ˆäº:</label>
                        <div class="calculated-profit" id="calculatedProfit">$0.00</div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="modal-btn cancel-btn" onclick="closeTradingModal()">å–æ¶ˆ</button>
                <button type="button" class="modal-btn confirm-btn" id="confirmTradeBtn" onclick="confirmTrade()">ç¡®è®¤</button>
            </div>
        </div>
    </div>

    <div id="toast" class="toast">
        <span id="toastMessage"></span>
    </div>

    <script>
        // Portfolio data
        let portfolio = [];
        let chartInstance = null;
        let portfolioTrendChart = null;
        let lastUpdateTime = null;
        let transactionHistory = []; // Track all buy/sell transactions
        let totalRealizedProfit = 0; // Track total realized profit/loss
        let currentTimeRange = '1D'; // Default to daily view
        let rawHistoricalData = []; // Store raw daily data for aggregation
        let cashBalance = 0; // Current cash balance

        // Finnhub API configuration
        const FINNHUB_API_KEY = 'd2mcdc9r01qq6foq0p40d2mcdc9r01qq6foq0p4g'; // Free tier API key
        
        // Cache to store prices and reduce API calls
        const priceCache = new Map();

        // Base prices for consistent simulation (updated daily)
        const basePrices = new Map();
        let lastPriceUpdateDate = null;
        const CACHE_DURATION = 60000; // Cache for 1 minute


        // Company names mapping
        const companyNames = {
            'AAPL': 'è‹¹æœå…¬å¸',
            'MSFT': 'å¾®è½¯',
            'GOOGL': 'è°·æ­Œ',
            'GOOG': 'è°·æ­Œ',
            'AMZN': 'äºšé©¬é€Š',
            'META': 'Meta',
            'TSLA': 'ç‰¹æ–¯æ‹‰',
            'NVDA': 'è‹±ä¼Ÿè¾¾',
            'TSM': 'å°ç§¯ç”µ',
            'BABA': 'é˜¿é‡Œå·´å·´',
            'JD': 'äº¬ä¸œ',
            'PDD': 'æ‹¼å¤šå¤š',
            'NIO': 'è”šæ¥',
            'BIDU': 'ç™¾åº¦',
            'NTES': 'ç½‘æ˜“',
            'TME': 'è…¾è®¯éŸ³ä¹',
            'BILI': 'å“”å“©å“”å“©',
            'AMD': 'AMD',
            'INTC': 'è‹±ç‰¹å°”',
            'DIS': 'è¿ªå£«å°¼',
            'NFLX': 'å¥ˆé£',
            'BA': 'æ³¢éŸ³',
            'V': 'Visa',
            'MA': 'ä¸‡äº‹è¾¾',
            'JPM': 'æ‘©æ ¹å¤§é€š',
            'BAC': 'ç¾å›½é“¶è¡Œ',
            'WMT': 'æ²ƒå°”ç›',
            'KO': 'å¯å£å¯ä¹',
            'PEP': 'ç™¾äº‹å¯ä¹',
            'MCD': 'éº¦å½“åŠ³',
            'SBUX': 'æ˜Ÿå·´å…‹',
            'NKE': 'è€å…‹',
            'ADBE': 'Adobe',
            'CRM': 'Salesforce',
            'ORCL': 'ç”²éª¨æ–‡',
            'IBM': 'IBM',
            'CSCO': 'æ€ç§‘',
            'QCOM': 'é«˜é€š',
            'TXN': 'å¾·å·ä»ªå™¨',
            'AVGO': 'åšé€š',
            'COST': 'å¥½å¸‚å¤š',
            'PG': 'å®æ´',
            'JNJ': 'å¼ºç”Ÿ',
            'UNH': 'è”åˆå¥åº·',
            'HD': 'å®¶å¾—å®',
            'CVX': 'é›ªä½›é¾™',
            'XOM': 'åŸƒå…‹æ£®ç¾å­š'
        };

        // Initialize
        window.onload = async function() {
            // ===== äº‘ç«¯åŒæ­¥åˆå§‹åŒ– =====
            await initCloudSync();
            // ===== äº‘ç«¯åŒæ­¥åˆå§‹åŒ–ç»“æŸ =====

            // æ³¨æ„ï¼šinitCloudSync()å·²ç»ä»äº‘ç«¯åŠ è½½æ•°æ®åˆ°portfolioã€cashBalanceç­‰å˜é‡
            // æ‰€ä»¥ä¸‹é¢çš„æœ¬åœ°åŠ è½½ä»£ç åªåœ¨äº‘ç«¯æ²¡æœ‰æ•°æ®æ—¶ä½œä¸ºfallback

            // å¦‚æœäº‘ç«¯æ²¡æœ‰åŠ è½½åˆ°æ•°æ®ï¼Œä»æœ¬åœ°åŠ è½½
            if (portfolio.length === 0) {
                const saved = localStorage.getItem('portfolio');
                if (saved) {
                    portfolio = JSON.parse(saved);
                }
            }

            if (cashBalance === 0) {
                const savedCash = localStorage.getItem('cashBalance');
                if (savedCash) {
                    cashBalance = parseFloat(savedCash);
                }
            }

            if (transactionHistory.length === 0) {
                await loadTransactionHistory(); // Load transaction history and realized profit
            }

            // Update cash display after loading
            updateCashDisplay();

            // Update all display data after loading
            updateDisplay();

            // Auto refresh prices on load
            if (portfolio.length > 0) {
                setTimeout(() => refreshAllPrices(), 1000);
            }

            // Set default date for cash transactions to today
            document.getElementById('cashDate').value = new Date().toISOString().split('T')[0];

            // Data is now automatically saved to browser cache
            console.log('Portfolio tracker loaded - all data automatically saved to browser cache');

            initChart();
            initPortfolioTrendChart();
            checkAPIStatus();

            // Initialize portfolio trend chart if we have data
            if (portfolio.length > 0 || transactionHistory.length > 0) {
                setTimeout(() => updatePortfolioTrendChart(), 2000);
            }
        };

        async function checkAPIStatus() {
            const apiStatus = document.getElementById('apiStatus');

            try {
                // æ£€æŸ¥APIæ˜¯å¦è¿è¡Œï¼ˆä½¿ç”¨é…ç½®çš„APIåœ°å€ï¼‰
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const response = await fetch(`${apiUrl}/api/health`);
                if (response.ok) {
                    const data = await response.json();
                    apiStatus.textContent = 'APIå·²è¿æ¥ (æœ¬åœ°PythonæœåŠ¡)';
                    apiStatus.className = 'api-status connected';
                } else {
                    throw new Error('å¥åº·æ£€æŸ¥å¤±è´¥');
                }
            } catch (error) {
                apiStatus.textContent = 'APIæœªè¿æ¥ (è¯·å¯åŠ¨PythonæœåŠ¡)';
                apiStatus.className = 'api-status error';
                console.warn('æœ¬åœ°APIæœåŠ¡æœªè¿è¡Œ:', error.message);
            }
        }

        function savePortfolio() {
            localStorage.setItem('portfolio', JSON.stringify(portfolio));
            // è§¦å‘äº‘ç«¯åŒæ­¥
            if (typeof syncToCloud === 'function') {
                syncToCloud().catch(err => console.error('äº‘ç«¯åŒæ­¥å¤±è´¥:', err));
            }
        }

        function saveCashBalance() {
            localStorage.setItem('cashBalance', cashBalance.toString());
            // è§¦å‘äº‘ç«¯åŒæ­¥
            if (typeof syncToCloud === 'function') {
                syncToCloud().catch(err => console.error('äº‘ç«¯åŒæ­¥å¤±è´¥:', err));
            }
        }

        // Cash management functions
        function depositCash() {
            const amountInput = document.getElementById('cashAmount');
            const dateInput = document.getElementById('cashDate');
            const amount = parseFloat(amountInput.value);
            const cashDate = dateInput.value;

            if (!amount || amount <= 0) {
                showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„è½¬å…¥é‡‘é¢', 'error');
                return;
            }

            if (!cashDate) {
                showToast('è¯·é€‰æ‹©äº¤æ˜“æ—¥æœŸ', 'error');
                return;
            }

            cashBalance += amount;
            saveCashBalance();

            // Record transaction first
            const transaction = {
                id: Date.now(),
                type: 'cash_deposit',
                amount: amount,
                date: cashDate + 'T12:00:00.000Z',
                timestamp: new Date().toISOString(),
                description: `èµ„é‡‘è½¬å…¥ $${amount.toFixed(2)}`
            };
            transactionHistory.push(transaction);
            saveTransactionHistory();

            // Then update display
            updateDisplay();

            amountInput.value = '';
            dateInput.value = '';
            showToast(`æˆåŠŸè½¬å…¥ $${amount.toFixed(2)}`, 'success');
        }

        function withdrawCash() {
            const amountInput = document.getElementById('cashAmount');
            const dateInput = document.getElementById('cashDate');
            const amount = parseFloat(amountInput.value);
            const cashDate = dateInput.value;

            if (!amount || amount <= 0) {
                showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„è½¬å‡ºé‡‘é¢', 'error');
                return;
            }

            if (!cashDate) {
                showToast('è¯·é€‰æ‹©äº¤æ˜“æ—¥æœŸ', 'error');
                return;
            }

            if (amount > cashBalance) {
                showToast('ç°é‡‘ä½™é¢ä¸è¶³', 'error');
                return;
            }

            cashBalance -= amount;
            saveCashBalance();

            // Record transaction first
            const transaction = {
                id: Date.now(),
                type: 'cash_withdrawal',
                amount: -amount,
                date: cashDate + 'T12:00:00.000Z',
                timestamp: new Date().toISOString(),
                description: `èµ„é‡‘è½¬å‡º $${amount.toFixed(2)}`
            };
            transactionHistory.push(transaction);
            saveTransactionHistory();

            // Then update display
            updateDisplay();

            amountInput.value = '';
            dateInput.value = '';
            showToast(`æˆåŠŸè½¬å‡º $${amount.toFixed(2)}`, 'success');
        }

        function saveTransactionHistory() {
            localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));
            localStorage.setItem('totalRealizedProfit', totalRealizedProfit.toString());

            // Also save to IndexedDB for better persistence
            saveToIndexedDB();

            // è§¦å‘äº‘ç«¯åŒæ­¥
            if (typeof syncToCloud === 'function') {
                syncToCloud().catch(err => console.error('äº‘ç«¯åŒæ­¥å¤±è´¥:', err));
            }
        }

        // Save to IndexedDB for better persistence
        async function saveToIndexedDB() {
            const data = {
                transactions: transactionHistory,
                totalRealizedProfit: totalRealizedProfit,
                lastUpdated: new Date().toISOString()
            };

            try {
                const request = indexedDB.open('PortfolioTracker', 1);
                request.onupgradeneeded = function(event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('transactions')) {
                        db.createObjectStore('transactions', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('data')) {
                        db.createObjectStore('data');
                    }
                };
                request.onsuccess = function(event) {
                    const db = event.target.result;
                    const transaction = db.transaction(['data'], 'readwrite');
                    const store = transaction.objectStore('data');
                    store.put(data, 'transactionData');
                };
            } catch (error) {
                console.error('Error saving to IndexedDB:', error);
            }
        }

        // Load from IndexedDB
        async function loadFromIndexedDB() {
            return new Promise((resolve) => {
                try {
                    const request = indexedDB.open('PortfolioTracker', 1);
                    request.onsuccess = function(event) {
                        const db = event.target.result;
                        if (db.objectStoreNames.contains('data')) {
                            const transaction = db.transaction(['data'], 'readonly');
                            const store = transaction.objectStore('data');
                            const getRequest = store.get('transactionData');
                            getRequest.onsuccess = function() {
                                resolve(getRequest.result || null);
                            };
                            getRequest.onerror = function() {
                                resolve(null);
                            };
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = function() {
                        resolve(null);
                    };
                } catch (error) {
                    resolve(null);
                }
            });
        }

        // Show notification
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 10000;
                font-family: inherit;
                max-width: 300px;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.3s';
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 3000);
        }

        async function loadTransactionHistory() {
            // First try to load from IndexedDB
            const indexedData = await loadFromIndexedDB();
            if (indexedData && indexedData.transactions) {
                transactionHistory = indexedData.transactions;
                totalRealizedProfit = indexedData.totalRealizedProfit || 0;
                console.log('Loaded transactions from IndexedDB:', indexedData);
                return;
            }

            // Fallback to localStorage
            const saved = localStorage.getItem('transactionHistory');
            if (saved) {
                transactionHistory = JSON.parse(saved);
            }

            const savedProfit = localStorage.getItem('totalRealizedProfit');
            if (savedProfit) {
                totalRealizedProfit = parseFloat(savedProfit);
            }

            // If we have localStorage data, save it to IndexedDB for future use
            if (transactionHistory.length > 0) {
                saveToIndexedDB();
            }
        }

        // Test local Python API connection
        async function testAPI(symbol = 'AAPL') {
            console.log('Testing local Python API with symbol:', symbol);
            showToast(`æ­£åœ¨æµ‹è¯•æœ¬åœ°Python API...`, 'info');

            try {
                console.log(`ğŸ”„ Testing Local Python API...`);

                const startTime = Date.now();
                const price = await fetchFromLocalAPI(symbol);
                const duration = Date.now() - startTime;

                if (price && price > 0) {
                    console.log(`âœ… æœ¬åœ°API - Success: $${price} (${duration}ms)`);
                    showToast(`âœ… æœ¬åœ°API - ${symbol}ä»·æ ¼: $${price.toFixed(2)} (${duration}ms)`, 'success');
                    return { api: 'æœ¬åœ°Python API', success: true, price, duration };
                } else {
                    console.log(`âŒ æœ¬åœ°API - Invalid price: ${price}`);
                    showToast(`âŒ æœ¬åœ°API - æ— æ•ˆä»·æ ¼`, 'error');
                    return { api: 'æœ¬åœ°Python API', success: false, error: 'Invalid price' };
                }
            } catch (error) {
                console.error(`âŒ æœ¬åœ°API - Error:`, error.message);
                showToast(`âŒ æœ¬åœ°API - å¤±è´¥: ${error.message} (è¯·ç¡®ä¿PythonæœåŠ¡æ­£åœ¨è¿è¡Œ)`, 'error');
                return { api: 'æœ¬åœ°Python API', success: false, error: error.message };
            }
        }

        // Make testAPI available globally for console testing
        window.testAPI = testAPI;

        // Test functions for debugging
        window.testYahoo = fetchFromYahoo;

        // Quick Yahoo Finance test function
        window.testYahooAPI = async function(symbol = 'AAPL') {
            console.log(`ğŸ§ª Testing Yahoo Finance API with symbol: ${symbol}`);

            try {
                console.log(`Testing Yahoo Finance...`);
                const price = await fetchFromYahoo(symbol);
                console.log(`âœ… Yahoo Finance: $${price}`);
                return price;
            } catch (error) {
                console.error(`âŒ Yahoo Finance: ${error.message}`);
                return null;
            }
        };

        // Test historical data APIs
        window.testHistoricalAPIs = async function(symbol = 'AAPL') {
            console.log(`ğŸ“Š Testing historical data APIs for ${symbol}...`);
            showToast(`å¼€å§‹æµ‹è¯• ${symbol} çš„å†å²æ•°æ®API...`, 'info');

            const results = [];

            // Test Alpha Vantage Historical Data
            try {
                console.log('ğŸ”„ Testing Alpha Vantage Historical...');
                const alphaUrl = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&apikey=demo&outputsize=compact`;
                const response = await fetch(alphaUrl);
                const data = await response.json();

                if (data['Time Series (Daily)']) {
                    const dates = Object.keys(data['Time Series (Daily)']).slice(0, 5);
                    console.log(`âœ… Alpha Vantage: è·å–åˆ° ${dates.length} å¤©æ•°æ®`);
                    console.log('æœ€è¿‘5å¤©:', dates.map(date => ({
                        date,
                        close: data['Time Series (Daily)'][date]['4. close']
                    })));
                    results.push({ api: 'Alpha Vantage', success: true, days: dates.length });
                } else {
                    console.log('âŒ Alpha Vantage: æ— æ•ˆå“åº”', data);
                    results.push({ api: 'Alpha Vantage', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('âŒ Alpha Vantage Historical:', error);
                results.push({ api: 'Alpha Vantage', success: false, error: error.message });
            }

            // Test Finnhub Historical Data
            try {
                console.log('ğŸ”„ Testing Finnhub Historical...');
                const endDate = Math.floor(Date.now() / 1000);
                const startDate = endDate - (30 * 24 * 60 * 60); // 30 days ago
                const finnhubUrl = `https://finnhub.io/api/v1/stock/candle?symbol=${symbol}&resolution=D&from=${startDate}&to=${endDate}&token=d2mcdc9r01qq6foq0p40d2mcdc9r01qq6foq0p4g`;

                const response = await fetch(finnhubUrl);
                const data = await response.json();

                if (data.s === 'ok' && data.c && data.c.length > 0) {
                    console.log(`âœ… Finnhub: è·å–åˆ° ${data.c.length} å¤©æ•°æ®`);
                    console.log('æœ€è¿‘5å¤©æ”¶ç›˜ä»·:', data.c.slice(-5));
                    results.push({ api: 'Finnhub', success: true, days: data.c.length });
                } else {
                    console.log('âŒ Finnhub: æ— æ•ˆå“åº”', data);
                    results.push({ api: 'Finnhub', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('âŒ Finnhub Historical:', error);
                results.push({ api: 'Finnhub', success: false, error: error.message });
            }

            // Test Yahoo Finance Historical
            try {
                console.log('ğŸ”„ Testing Yahoo Historical...');
                const endTime = Math.floor(Date.now() / 1000);
                const startTime = endTime - (30 * 24 * 60 * 60);
                const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${startTime}&period2=${endTime}&interval=1d`;

                const response = await fetch(yahooUrl);
                const data = await response.json();

                if (data.chart && data.chart.result && data.chart.result[0] && data.chart.result[0].indicators) {
                    const quotes = data.chart.result[0].indicators.quote[0];
                    const closes = quotes.close.filter(c => c !== null);
                    console.log(`âœ… Yahoo Finance: è·å–åˆ° ${closes.length} å¤©æ•°æ®`);
                    console.log('æœ€è¿‘5å¤©æ”¶ç›˜ä»·:', closes.slice(-5));
                    results.push({ api: 'Yahoo Finance', success: true, days: closes.length });
                } else {
                    console.log('âŒ Yahoo Finance: æ— æ•ˆå“åº”', data);
                    results.push({ api: 'Yahoo Finance', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('âŒ Yahoo Finance Historical:', error);
                results.push({ api: 'Yahoo Finance', success: false, error: error.message });
            }

            // Test Financial Modeling Prep Historical
            try {
                console.log('ğŸ”„ Testing FMP Historical...');
                const fmpUrl = `https://financialmodelingprep.com/api/v3/historical-price-full/${symbol}?timeseries=30&apikey=demo`;

                const response = await fetch(fmpUrl);
                const data = await response.json();

                if (data.historical && data.historical.length > 0) {
                    console.log(`âœ… FMP: è·å–åˆ° ${data.historical.length} å¤©æ•°æ®`);
                    console.log('æœ€è¿‘5å¤©:', data.historical.slice(0, 5).map(d => ({ date: d.date, close: d.close })));
                    results.push({ api: 'Financial Modeling Prep', success: true, days: data.historical.length });
                } else {
                    console.log('âŒ FMP: æ— æ•ˆå“åº”', data);
                    results.push({ api: 'Financial Modeling Prep', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('âŒ FMP Historical:', error);
                results.push({ api: 'Financial Modeling Prep', success: false, error: error.message });
            }

            // Test Twelve Data Historical
            try {
                console.log('ğŸ”„ Testing Twelve Data Historical...');
                const twelveUrl = `https://api.twelvedata.com/time_series?symbol=${symbol}&interval=1day&outputsize=30&apikey=demo`;

                const response = await fetch(twelveUrl);
                const data = await response.json();

                if (data.values && data.values.length > 0) {
                    console.log(`âœ… Twelve Data: è·å–åˆ° ${data.values.length} å¤©æ•°æ®`);
                    console.log('æœ€è¿‘5å¤©:', data.values.slice(0, 5).map(d => ({ date: d.datetime, close: d.close })));
                    results.push({ api: 'Twelve Data', success: true, days: data.values.length });
                } else {
                    console.log('âŒ Twelve Data: æ— æ•ˆå“åº”', data);
                    results.push({ api: 'Twelve Data', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('âŒ Twelve Data Historical:', error);
                results.push({ api: 'Twelve Data', success: false, error: error.message });
            }

            // Test IEX Cloud Historical (sandbox)
            try {
                console.log('ğŸ”„ Testing IEX Cloud Historical...');
                const iexUrl = `https://cloud.iexapis.com/stable/stock/${symbol}/chart/1m?token=pk_test_free`;

                const response = await fetch(iexUrl);
                const data = await response.json();

                if (Array.isArray(data) && data.length > 0) {
                    console.log(`âœ… IEX Cloud: è·å–åˆ° ${data.length} å¤©æ•°æ®`);
                    console.log('æœ€è¿‘5å¤©:', data.slice(-5).map(d => ({ date: d.date, close: d.close })));
                    results.push({ api: 'IEX Cloud', success: true, days: data.length });
                } else {
                    console.log('âŒ IEX Cloud: æ— æ•ˆå“åº”', data);
                    results.push({ api: 'IEX Cloud', success: false, error: 'Invalid response' });
                }
            } catch (error) {
                console.error('âŒ IEX Cloud Historical:', error);
                results.push({ api: 'IEX Cloud', success: false, error: error.message });
            }

            console.log('\nğŸ“Š å†å²æ•°æ®APIæµ‹è¯•ç»“æœ:', results);

            const successCount = results.filter(r => r.success).length;
            showToast(`å†å²æ•°æ®æµ‹è¯•å®Œæˆï¼${successCount}/${results.length} ä¸ªAPIå¯ç”¨`, successCount > 0 ? 'success' : 'warning');

            return results;
        };

        // Fetch real 30-day historical data from local API
        window.fetchReal30DayHistory = async function(symbol) {
            console.log(`ğŸ“ˆ è·å– ${symbol} çœŸå®30å¤©å†å²æ•°æ®...`);
            showToast(`æ­£åœ¨ä»APIè·å– ${symbol} çš„çœŸå®å†å²æ•°æ®...`, 'info');

            try {
                console.log('ğŸ”„ å°è¯•Python API...');
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const url = `${apiUrl}/api/history/${symbol}?period=1M`;

                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    const historicalData = data.data;

                    console.log(`âœ… æœ¬åœ°API: è·å–åˆ° ${historicalData.length} å¤©çœŸå®æ•°æ®`);
                    console.log('æ•°æ®ç¤ºä¾‹:', historicalData.slice(0, 3));
                    showToast(`âœ… è·å–åˆ° ${historicalData.length} å¤© ${symbol} çœŸå®å†å²æ•°æ®`, 'success');
                    return historicalData;
                } else {
                    throw new Error(data.error || 'æœ¬åœ°APIè¿”å›æ— æ•ˆæ•°æ®');
                }
            } catch (error) {
                console.error('âŒ æœ¬åœ°API å¤±è´¥:', error);
                console.warn('âš ï¸ æ— æ³•è·å–çœŸå®å†å²æ•°æ®ï¼Œå»ºè®®ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
                showToast(`âš ï¸ æ— æ³•è·å– ${symbol} çœŸå®å†å²æ•°æ®: ${error.message}`, 'warning');
                return null;
            }
        };

        // Toggle stock details visibility
        function toggleStockDetails(stockId) {
            const container = document.getElementById(`details-${stockId}`);
            const icon = document.getElementById(`toggle-${stockId}`);

            if (container.style.display === 'none') {
                container.style.display = 'grid';
                icon.textContent = 'â–²';
                icon.classList.add('expanded');

                // Load real stock data when expanded
                loadStockDetails(stockId);
            } else {
                container.style.display = 'none';
                icon.textContent = 'â–¼';
                icon.classList.remove('expanded');
            }
        }

        // Load and populate real stock details
        async function loadStockDetails(stockId) {
            const stock = portfolio.find(s => s.id === stockId);
            if (!stock) return;

            const specsContainer = document.getElementById(`specs-${stockId}`);
            if (!specsContainer) return;

            try {
                const details = await fetchStockDetails(stock.symbol);

                if (details) {
                    // Update all spec values with real data
                    const specItems = specsContainer.querySelectorAll('.spec-item');

                    // Map data to display fields
                    const dataMap = [
                        details.previousClose?.toFixed(2) || 'N/A',
                        details.open?.toFixed(2) || 'N/A',
                        `${details.low?.toFixed(2) || 'N/A'} - ${details.high?.toFixed(2) || 'N/A'}`,
                        `${details.week52Low?.toFixed(2) || 'N/A'} - ${details.week52High?.toFixed(2) || 'N/A'}`,
                        details.volume ? details.volume.toLocaleString('zh-CN') : 'N/A',
                        details.marketCap ? (details.marketCap / 1000).toFixed(3) + 'T' : 'N/A',
                        details.beta?.toFixed(2) || 'N/A',
                        details.peRatio?.toFixed(2) || 'N/A',
                        details.eps?.toFixed(2) || 'N/A',
                        details.currency || 'USD'
                    ];

                    specItems.forEach((item, index) => {
                        const valueSpan = item.querySelector('.spec-value');
                        if (valueSpan && dataMap[index]) {
                            valueSpan.textContent = dataMap[index];
                            valueSpan.classList.remove('loading-data');
                        }
                    });

                    showToast(`${stock.symbol} è¯¦ç»†ä¿¡æ¯å·²æ›´æ–°`, 'success');
                } else {
                    showToast(`æ— æ³•è·å– ${stock.symbol} çš„è¯¦ç»†ä¿¡æ¯`, 'error');
                }
            } catch (error) {
                console.error(`Error loading details for ${stock.symbol}:`, error);
                showToast(`è·å– ${stock.symbol} è¯¦ç»†ä¿¡æ¯å¤±è´¥`, 'error');
            }
        }

        // Trading Modal Variables
        let currentTradeStock = null;
        let currentTradeType = null;

        // Open trading modal
        function openTradingModal(stockId, tradeType) {
            const stock = portfolio.find(s => s.id === stockId);
            if (!stock) return;

            currentTradeStock = stock;
            currentTradeType = tradeType;

            const modal = document.getElementById('tradingModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalStockInfo = document.getElementById('modalStockInfo');
            const sharesHint = document.getElementById('sharesHint');
            const priceHint = document.getElementById('priceHint');
            const profitInfo = document.getElementById('profitInfo');
            const confirmBtn = document.getElementById('confirmTradeBtn');

            // Configure modal based on trade type
            if (tradeType === 'buy') {
                modalTitle.textContent = 'ğŸ“ˆ åŠ ä»“æ“ä½œ';
                sharesHint.textContent = 'è¾“å…¥è¦åŠ ä»“çš„è‚¡æ•°';
                priceHint.textContent = `å»ºè®®ä»·æ ¼: $${stock.currentPrice.toFixed(2)}`;
                profitInfo.style.display = 'none';
                confirmBtn.textContent = 'ç¡®è®¤åŠ ä»“';
                confirmBtn.className = 'modal-btn confirm-btn';
            } else if (tradeType === 'sell') {
                modalTitle.textContent = 'ğŸ“‰ å‡ä»“æ“ä½œ';
                sharesHint.textContent = `æœ€å¤šå¯å–: ${stock.shares.toFixed(2)} è‚¡`;
                priceHint.textContent = `å»ºè®®ä»·æ ¼: $${stock.currentPrice.toFixed(2)}`;
                profitInfo.style.display = 'block';
                confirmBtn.textContent = 'ç¡®è®¤å‡ä»“';
                confirmBtn.className = 'modal-btn confirm-btn sell';
            } else if (tradeType === 'delete') {
                modalTitle.textContent = 'ğŸ—‘ï¸ æ¸…ä»“æ“ä½œ';
                sharesHint.textContent = `å°†å–å‡ºå…¨éƒ¨ ${stock.shares.toFixed(2)} è‚¡`;
                priceHint.textContent = `å»ºè®®ä»·æ ¼: $${stock.currentPrice.toFixed(2)}`;
                profitInfo.style.display = 'block';
                confirmBtn.textContent = 'ç¡®è®¤æ¸…ä»“';
                confirmBtn.className = 'modal-btn confirm-btn delete';

                // Pre-fill shares for delete operation
                document.getElementById('modalShares').value = stock.shares.toFixed(2);
                document.getElementById('modalShares').readOnly = true;
            }

            modalStockInfo.textContent = `${stock.symbol} - å½“å‰æŒè‚¡: ${stock.shares.toFixed(2)} è‚¡ | æˆæœ¬ä»·: $${stock.buyPrice.toFixed(2)} | å½“å‰ä»·: $${stock.currentPrice.toFixed(2)}`;

            // Pre-fill current price
            document.getElementById('modalPrice').value = stock.currentPrice.toFixed(2);

            // Add input listeners for real-time calculation
            setupModalCalculations();

            modal.style.display = 'block';
        }

        // Close trading modal
        function closeTradingModal() {
            const modal = document.getElementById('tradingModal');
            modal.style.display = 'none';

            // Reset form
            document.getElementById('tradingForm').reset();
            document.getElementById('modalShares').readOnly = false;
            currentTradeStock = null;
            currentTradeType = null;
        }

        // Setup real-time calculations in modal
        function setupModalCalculations() {
            const sharesInput = document.getElementById('modalShares');
            const priceInput = document.getElementById('modalPrice');
            const feeInput = document.getElementById('modalFee');

            function calculateAmounts() {
                const shares = parseFloat(sharesInput.value) || 0;
                const price = parseFloat(priceInput.value) || 0;
                const feePerShare = parseFloat(feeInput.value) || 0;
                const totalAmount = shares * price;
                const totalFee = shares * feePerShare;

                document.getElementById('calculatedAmount').textContent = `$${totalAmount.toFixed(2)}`;
                document.getElementById('calculatedFee').textContent = `$${totalFee.toFixed(2)}`;

                // Calculate profit for sell operations
                if (currentTradeType === 'sell' || currentTradeType === 'delete') {
                    // Include fees in profit calculation
                    const profit = (price - currentTradeStock.buyPrice) * shares - totalFee;
                    const profitElement = document.getElementById('calculatedProfit');
                    profitElement.textContent = `${profit >= 0 ? '+' : ''}$${profit.toFixed(2)}`;
                    profitElement.className = `calculated-profit ${profit >= 0 ? 'positive' : 'negative'}`;
                }
            }

            sharesInput.addEventListener('input', calculateAmounts);
            priceInput.addEventListener('input', calculateAmounts);
            feeInput.addEventListener('input', calculateAmounts);

            // Initial calculation
            calculateAmounts();
        }

        // Confirm trade operation
        function confirmTrade() {
            const shares = parseFloat(document.getElementById('modalShares').value);
            const price = parseFloat(document.getElementById('modalPrice').value);
            const feePerShare = parseFloat(document.getElementById('modalFee').value) || 0;

            if (!shares || shares <= 0 || !price || price <= 0) {
                showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„è‚¡æ•°å’Œä»·æ ¼', 'error');
                return;
            }

            if (currentTradeType === 'buy') {
                executeBuyMore(currentTradeStock.id, shares, price, feePerShare);
            } else if (currentTradeType === 'sell') {
                if (shares >= currentTradeStock.shares) {
                    showToast('å‡ä»“è‚¡æ•°ä¸èƒ½å¤§äºç­‰äºæŒæœ‰è‚¡æ•°ï¼Œè¯·ä½¿ç”¨æ¸…ä»“åŠŸèƒ½', 'error');
                    return;
                }
                executeSellPart(currentTradeStock.id, shares, price, feePerShare);
            } else if (currentTradeType === 'delete') {
                executeDelete(currentTradeStock.id, price, feePerShare);
            }

            closeTradingModal();
        }

        // Handle individual stock chart time range change
        function onStockTimeRangeChange(stockId, period) {
            console.log(`ğŸ“Š åˆ‡æ¢è‚¡ç¥¨ ${stockId} å›¾è¡¨æ—¶é—´å‘¨æœŸ: ${period}`);

            // Update button states
            const selector = document.getElementById(`stockTimeSelector-${stockId}`);
            if (selector) {
                const buttons = selector.querySelectorAll('.time-btn');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.period === period) {
                        btn.classList.add('active');
                    }
                });
            }

            const stock = portfolio.find(s => s.id == stockId);
            if (stock) {
                renderStockChart(stock, period);
                showToast(`${stock.symbol} åˆ‡æ¢åˆ°${getTimeRangeDisplayName(period)}è§†å›¾`, 'success');
            }
        }

        // Make functions globally available
        window.toggleStockDetails = toggleStockDetails;
        window.buyMoreStock = (id) => openTradingModal(id, 'buy');
        window.sellPartStock = (id) => openTradingModal(id, 'sell');
        window.deleteStock = (id) => openTradingModal(id, 'delete');
        window.openTradingModal = openTradingModal;
        window.closeTradingModal = closeTradingModal;
        window.confirmTrade = confirmTrade;
        window.onStockTimeRangeChange = onStockTimeRangeChange;
        window.selectTimeRange = selectTimeRange;

        // Financial Data API (Free tier, CORS enabled)
        async function fetchFromFinancialData(symbol) {
            // Using a free API with CORS support
            const url = `https://financialmodelingprep.com/api/v3/quote-short/${symbol}?apikey=demo`;

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Financial Data API HTTP ${response.status}`);
            }

            const data = await response.json();

            if (!data || !Array.isArray(data) || data.length === 0) {
                throw new Error('Invalid Financial Data API response');
            }

            const price = data[0].price;

            if (!price || price <= 0) {
                throw new Error('No valid price from Financial Data API');
            }

            return price;
        }


        // Python API (ä½¿ç”¨yfinance)
        async function fetchFromLocalAPI(symbol) {
            try {
                // è°ƒç”¨Python APIæœåŠ¡
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const url = `${apiUrl}/api/price/${symbol}`;

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`æœ¬åœ°API HTTP ${response.status}`);
                }

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'æœ¬åœ°APIè¿”å›é”™è¯¯');
                }

                const price = data.price;

                if (!price || price <= 0) {
                    throw new Error('æœ¬åœ°APIè¿”å›æ— æ•ˆä»·æ ¼');
                }

                return price;
            } catch (error) {
                console.error('æœ¬åœ°APIè°ƒç”¨å¤±è´¥:', error);
                throw error;
            }
        }

        // ä¸ºäº†ä¿æŒå…¼å®¹æ€§ï¼Œä¿ç•™fetchFromYahooåç§°ä½†ä½¿ç”¨æœ¬åœ°API
        async function fetchFromYahoo(symbol) {
            return await fetchFromLocalAPI(symbol);
        }




        // Fetch comprehensive stock data using Finnhub
        async function fetchStockDetails(symbol) {

            try {
                // Fetch multiple endpoints for comprehensive data
                const [quoteResponse, profileResponse, metricsResponse] = await Promise.all([
                    fetch(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`),
                    fetch(`https://finnhub.io/api/v1/stock/profile2?symbol=${symbol}&token=${FINNHUB_API_KEY}`),
                    fetch(`https://finnhub.io/api/v1/stock/metric?symbol=${symbol}&metric=all&token=${FINNHUB_API_KEY}`)
                ]);

                const [quote, profile, metrics] = await Promise.all([
                    quoteResponse.json(),
                    profileResponse.json(),
                    metricsResponse.json()
                ]);

                return {
                    // Basic price data
                    currentPrice: quote.c || 0,
                    previousClose: quote.pc || 0,
                    open: quote.o || 0,
                    high: quote.h || 0,
                    low: quote.l || 0,

                    // 52-week data
                    week52High: metrics.metric?.['52WeekHigh'] || 0,
                    week52Low: metrics.metric?.['52WeekLow'] || 0,

                    // Market cap and financial metrics
                    marketCap: profile.marketCapitalization || 0,
                    peRatio: metrics.metric?.peBasicExclExtraTTM || 0,
                    eps: metrics.metric?.epsBasicExclExtraAnnual || 0,
                    beta: metrics.metric?.beta || 0,

                    // Volume data
                    volume: quote.t || 0, // Last trading timestamp as volume placeholder

                    // Company info
                    name: profile.name || symbol,
                    exchange: profile.exchange || 'NASDAQ',
                    currency: profile.currency || 'USD'
                };
            } catch (error) {
                console.error(`Error fetching stock details for ${symbol}:`, error);
                return null;
            }
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }


        // Fetch real stock price using Yahoo Finance API
        async function fetchStockPrice(symbol) {
            // Validate symbol
            if (!symbol || symbol === 'undefined' || symbol.trim() === '') {
                console.error('Invalid symbol for fetchStockPrice:', symbol);
                return null;
            }

            // Check cache first (increased cache duration for session consistency)
            const cached = priceCache.get(symbol);
            const SESSION_CACHE_DURATION = 300000; // 5 minutes for consistent session experience
            if (cached && Date.now() - cached.timestamp < SESSION_CACHE_DURATION) {
                console.log(`Using cached price for ${symbol}: $${cached.price.toFixed(2)}`);
                return cached.price;
            }

            // Try Yahoo Finance API (most reliable free option)
            try {
                console.log(`ğŸ”„ Fetching ${symbol} price from Yahoo Finance...`);
                showToast(`ğŸ”„ æ­£åœ¨ä» Yahoo Finance è·å– ${symbol} ä»·æ ¼...`, 'info');

                const startTime = Date.now();
                const price = await fetchFromYahoo(symbol);
                const duration = Date.now() - startTime;

                if (price && price > 0) {
                    // Cache the price
                    priceCache.set(symbol, {
                        price: price,
                        timestamp: Date.now()
                    });

                    console.log(`âœ… Yahoo Finance - Fetched price for ${symbol}: $${price} (${duration}ms)`);
                    showToast(`âœ… ${symbol}: $${price.toFixed(2)} (Yahoo Finance)`, 'success');
                    return price;
                } else {
                    console.warn(`âš ï¸ Yahoo Finance returned invalid price: ${price}`);
                    showToast(`âš ï¸ Yahoo Finance è¿”å›æ— æ•ˆä»·æ ¼`, 'warning');
                }
            } catch (error) {
                console.error(`âŒ Yahoo Finance failed for ${symbol}:`, error);
                showToast(`âŒ Yahoo Finance è·å–å¤±è´¥: ${error.message}`, 'error');
            }

            // If Yahoo Finance fails, use cached price or demo price
            console.error(`Yahoo Finance failed for ${symbol}, using fallback`);
            if (cached) {
                showToast(`ä½¿ç”¨ç¼“å­˜ä»·æ ¼ ${symbol}`, 'warning');
                return cached.price;
            }

            // Fallback to demo prices if Yahoo Finance fails
            showToast(`ä½¿ç”¨æ¨¡æ‹Ÿä»·æ ¼ ${symbol}`, 'info');
            return generateSimulatedPrice(symbol);
        }

        // Generate 30-day historical prices for a stock symbol
        function generate30DayHistory(symbol, endPrice = null) {
            const stockBasePrices = {
                'AAPL': 234,      // Apple
                'MSFT': 420,      // Microsoft
                'GOOGL': 155,     // Alphabet
                'AMZN': 178,      // Amazon
                'META': 510,      // Meta
                'TSLA': 240,      // Tesla
                'NVDA': 880,      // NVIDIA
                'TSM': 165,       // Taiwan Semi
                'BABA': 85,       // Alibaba
                'JD': 40,         // JD.com
                'PDD': 138,       // PDD
                'NIO': 5,         // NIO
                'BIDU': 105,      // Baidu
                'NTES': 95,       // NetEase
                'TME': 8,         // Tencent Music
                'BILI': 16        // Bilibili
            };

            // Get base price for this symbol
            const basePrice = endPrice || stockBasePrices[symbol] || (50 + Math.random() * 200);
            const history = [];

            // Generate 30 trading days of historical data
            let currentPrice = basePrice;
            const today = new Date();

            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);

                // Skip weekends (Saturday = 6, Sunday = 0)
                if (date.getDay() === 0 || date.getDay() === 6) {
                    continue;
                }

                // Generate realistic daily price movement (-3% to +3%)
                const dailyChange = (Math.random() - 0.5) * 0.06; // -3% to +3%
                currentPrice = currentPrice * (1 + dailyChange);

                // Add some market trend (slight upward bias)
                const trendFactor = 1 + (Math.random() * 0.002 - 0.001); // Very small trend
                currentPrice *= trendFactor;

                history.push({
                    date: date.toISOString().split('T')[0],
                    close: parseFloat(currentPrice.toFixed(2)),
                    volume: Math.floor(Math.random() * 10000000) + 1000000 // Random volume
                });
            }

            return history;
        }

        // Generate realistic simulated prices with consistent daily updates
        function generateSimulatedPrice(symbol) {
            const today = new Date().toDateString();

            // Check if we need to update base prices for a new day
            if (lastPriceUpdateDate !== today) {
                updateBasePrices();
                lastPriceUpdateDate = today;
            }

            // Get base price for this symbol
            let basePrice = basePrices.get(symbol);
            if (!basePrice) {
                // Initialize base price if it doesn't exist
                const stockBasePrices = {
                    'AAPL': 234,      // Apple
                    'MSFT': 420,      // Microsoft
                    'GOOGL': 155,     // Alphabet
                    'AMZN': 178,      // Amazon
                    'META': 510,      // Meta
                    'TSLA': 240,      // Tesla
                    'NVDA': 880,      // NVIDIA
                    'TSM': 165,       // Taiwan Semi
                    'BABA': 85,       // Alibaba
                    'JD': 40,         // JD.com
                    'PDD': 138,       // PDD
                    'NIO': 5,         // NIO
                    'BIDU': 105,      // Baidu
                    'NTES': 95,       // NetEase
                    'TME': 8,         // Tencent Music
                    'BILI': 16        // Bilibili
                };

                basePrice = stockBasePrices[symbol] || (50 + Math.random() * 200);
                basePrices.set(symbol, basePrice);
            }

            // Add small intraday volatility (Â±0.5%)
            const intradayVariation = 0.005; // 0.5% max variation
            const variation = (Math.random() - 0.5) * 2 * intradayVariation;
            const currentPrice = basePrice * (1 + variation);

            // Cache the simulated price for session consistency
            priceCache.set(symbol, {
                price: currentPrice,
                timestamp: Date.now()
            });

            showToast(`ä½¿ç”¨æ¨¡æ‹Ÿä»·æ ¼ ${symbol}: $${currentPrice.toFixed(2)}`, 'warning');

            return Math.max(currentPrice, 1); // Ensure positive price
        }

        // Update base prices with realistic daily movements
        function updateBasePrices() {
            console.log('æ›´æ–°æ¯æ—¥åŸºç¡€ä»·æ ¼...');

            for (const [symbol, price] of basePrices.entries()) {
                // Generate realistic daily change (Â±3% for most stocks)
                const volatility = getSymbolVolatility(symbol);
                const dailyChange = (Math.random() - 0.5) * 2 * volatility;
                const newPrice = price * (1 + dailyChange);

                basePrices.set(symbol, Math.max(newPrice, 1));
                console.log(`${symbol}: $${price.toFixed(2)} â†’ $${newPrice.toFixed(2)} (${(dailyChange * 100).toFixed(2)}%)`);
            }
        }

        // Get volatility for different symbols
        function getSymbolVolatility(symbol) {
            const symbolVolatility = {
                'AAPL': 0.02,    // Apple - 2% daily volatility
                'MSFT': 0.018,   // Microsoft
                'GOOGL': 0.025,  // Alphabet
                'AMZN': 0.03,    // Amazon
                'META': 0.035,   // Meta
                'TSLA': 0.05,    // Tesla - high volatility
                'NVDA': 0.04,    // NVIDIA
                'TSM': 0.03,     // Taiwan Semi
                'BABA': 0.04,    // Alibaba
                'JD': 0.045,     // JD.com
                'PDD': 0.05,     // PDD
                'NIO': 0.06,     // NIO - very high volatility
                'BIDU': 0.04,    // Baidu
                'NTES': 0.03,    // NetEase
                'TME': 0.045,    // Tencent Music
                'BILI': 0.055    // Bilibili
            };

            return symbolVolatility[symbol] || 0.03; // Default 3% volatility
        }

        // Batch fetch prices with delay to respect API limits
        async function fetchMultiplePrices(symbols) {
            const prices = {};
            const delay = 12000; // 12 seconds between calls (Alpha Vantage free tier: 5 calls/minute)
            
            for (let i = 0; i < symbols.length; i++) {
                const symbol = symbols[i];
                try {
                    prices[symbol] = await fetchStockPrice(symbol);
                    
                    // Show progress
                    if (symbols.length > 1) {
                        showToast(`æ›´æ–°è¿›åº¦: ${i + 1}/${symbols.length} - ${symbol}`, 'success');
                    }
                    
                    // Wait between API calls to respect rate limit (except for last one)
                    if (i < symbols.length - 1 && symbols.length > 5) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                } catch (error) {
                    console.error(`Failed to fetch ${symbol}:`, error);
                    prices[symbol] = null;
                }
            }
            
            return prices;
        }

        // Fetch historical price data for individual stock charts
        async function fetchHistoricalData(symbol, period = '1M') {
            // Validate symbol
            if (!symbol || symbol === 'undefined' || symbol.trim() === '') {
                console.error('Invalid symbol for fetchHistoricalData:', symbol);
                return [];
            }

            try {
                console.log(`ğŸ”„ è·å– ${symbol} å†å²æ•°æ®ï¼Œå‘¨æœŸ: ${period}`);

                // ä¼˜å…ˆä½¿ç”¨æœ¬åœ°API (æ”¯æŒperiodå‚æ•°)
                try {
                    const historicalData = await fetchHistoricalFromLocalAPIByPeriod(symbol, period);
                    if (historicalData && historicalData.length > 0) {
                        console.log(`âœ… ${symbol} æœ¬åœ°APIè·å–æˆåŠŸï¼Œ${historicalData.length}ä¸ªæ•°æ®ç‚¹`);
                        return historicalData.map(item => ({
                            date: item.date,
                            price: item.close
                        }));
                    }
                } catch (localError) {
                    console.warn(`æœ¬åœ°APIè·å–å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ–¹æ¡ˆ: ${localError}`);
                }

                // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨Alpha Vantage API
                const endDate = new Date();
                const startDate = new Date();

                switch (period) {
                    case '1D':
                        startDate.setDate(endDate.getDate() - 30);
                        break;
                    case '1W':
                        startDate.setDate(endDate.getDate() - 7);
                        break;
                    case '1M':
                        startDate.setDate(endDate.getDate() - 30);
                        break;
                    case '3M':
                        startDate.setDate(endDate.getDate() - 90);
                        break;
                    case '6M':
                        startDate.setDate(endDate.getDate() - 180);
                        break;
                    case 'YTD':
                        startDate.setMonth(0, 1); // January 1st
                        break;
                    default:
                        startDate.setDate(endDate.getDate() - 30);
                }

                const priceHistory = await fetchHistoricalPricesForSymbol(symbol, startDate, endDate);
                if (!priceHistory) {
                    console.error(`No historical data available for ${symbol}`);
                    return null;
                }

                return priceHistory.map(item => ({
                    date: item.date,
                    price: item.price
                }));

            } catch (error) {
                console.error(`Error fetching historical data for ${symbol}:`, error);
                showToast(`${symbol} æ— æ³•è·å–å†å²æ•°æ®`, 'error');
                return null;
            }
        }

        // Generate mock historical data for demo purposes
        function generateMockHistoricalData(symbol, period = '1M') {
            const days = period === '1M' ? 30 : 7;
            const data = [];
            const today = new Date();

            // Get current price from cache or use a default
            let currentPrice = priceCache.get(symbol)?.price;
            if (!currentPrice) {
                // If no cached price, find it from portfolio or use demo prices
                const stockInPortfolio = portfolio.find(s => s.symbol === symbol);
                currentPrice = stockInPortfolio?.currentPrice || 150; // Default fallback
            }

            // Start with a price 30 days ago and build realistic movement
            let startPrice = currentPrice * (0.9 + Math.random() * 0.2); // Â±10% from current

            for (let i = days - 1; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(today.getDate() - i);

                // Generate realistic price movement that trends toward current price
                const daysFromEnd = i;
                const progressToPresent = (days - 1 - daysFromEnd) / (days - 1);

                // Blend between start price and current price with some random walk
                const targetPrice = startPrice + (currentPrice - startPrice) * progressToPresent;
                const volatility = 0.015; // 1.5% daily volatility
                const dailyChange = (Math.random() - 0.5) * 2 * volatility;

                let price;
                if (i === 0) {
                    // Last day should be very close to current price
                    price = currentPrice * (0.995 + Math.random() * 0.01);
                } else {
                    price = targetPrice * (1 + dailyChange);
                }

                data.push({
                    date: date.toISOString().split('T')[0],
                    price: Math.max(price, 1) // Ensure positive price
                });
            }

            return data;
        }

        async function addStock() {
            const symbol = document.getElementById('stockSymbol').value.toUpperCase();
            const shares = parseFloat(document.getElementById('shares').value);
            const buyPrice = parseFloat(document.getElementById('buyPrice').value);
            const feePerShare = parseFloat(document.getElementById('initialFee').value) || 0;
            const buyDate = document.getElementById('buyDate').value;

            if (!symbol || !shares || !buyPrice || !buyDate) {
                showToast('è¯·å¡«å†™æ‰€æœ‰å¿…å¡«å­—æ®µ', 'error');
                return;
            }

            // Calculate total cost including fees
            const totalCost = (shares * buyPrice) + (shares * feePerShare);

            // Check if user has enough cash
            if (totalCost > cashBalance) {
                showToast(`ç°é‡‘ä½™é¢ä¸è¶³ï¼éœ€è¦ $${totalCost.toFixed(2)}ï¼Œä½†åªæœ‰ $${cashBalance.toFixed(2)}`, 'error');
                return;
            }

            // Show loading
            showToast('æ­£åœ¨è·å–æœ€æ–°ä»·æ ¼...', 'success');

            try {
                // Fetch current price
                const currentPrice = await fetchStockPrice(symbol);

                // Calculate total fee but don't include in displayed buy price
                const totalFee = shares * feePerShare;

                // Check if this stock already exists in portfolio
                const existingStock = portfolio.find(s => s.symbol === symbol);

                if (existingStock) {
                    // åˆå¹¶ç›¸åŒè‚¡ç¥¨ï¼šè®¡ç®—åŠ æƒå¹³å‡æˆæœ¬
                    const oldTotalCost = existingStock.shares * existingStock.buyPrice;
                    const newTotalCost = shares * buyPrice;
                    const combinedShares = existingStock.shares + shares;
                    const weightedAvgPrice = (oldTotalCost + newTotalCost + totalFee) / combinedShares;

                    // æ›´æ–°ç°æœ‰è‚¡ç¥¨
                    existingStock.shares = combinedShares;
                    existingStock.buyPrice = weightedAvgPrice;
                    existingStock.currentPrice = currentPrice;
                    existingStock.lastUpdate = new Date().toISOString();

                    showToast(`å·²åˆå¹¶ ${symbol} è‚¡ç¥¨ï¼Œæ–°çš„å¹³å‡æˆæœ¬ä»·ï¼š$${weightedAvgPrice.toFixed(2)}`, 'success');
                } else {
                    // æ–°è‚¡ç¥¨ï¼šåˆ›å»ºæ–°çš„æŠ•èµ„ç»„åˆæ¡ç›®
                    const stock = {
                        id: Date.now(),
                        symbol,
                        companyName: companyNames[symbol] || symbol,
                        shares,
                        buyPrice: (buyPrice * shares + totalFee) / shares, // Include fees in cost basis
                        currentPrice,
                        previousClose: currentPrice, // For daily change calculation
                        buyDate,
                        lastUpdate: new Date().toISOString()
                    };

                    portfolio.push(stock);
                }

                // Record initial buy transaction
                const transaction = {
                    id: Date.now() + 1, // Slightly different ID to avoid collision
                    stockSymbol: symbol,
                    type: 'buy',
                    shares: shares,
                    price: buyPrice,
                    feePerShare: feePerShare,
                    totalFee: totalFee,
                    totalValue: buyPrice * shares,
                    realizedProfit: 0,
                    date: buyDate + 'T12:00:00.000Z',
                    note: 'åˆå§‹ä¹°å…¥'
                };

                transactionHistory.push(transaction);

                // Deduct cash for purchase
                cashBalance -= totalCost;
                saveCashBalance();

                savePortfolio();
                saveTransactionHistory();
                updateDisplay();
                clearForm();
                showToast(`æˆåŠŸæ·»åŠ  ${symbol} åˆ°æŠ•èµ„ç»„åˆï¼å·²æ‰£é™¤ $${totalCost.toFixed(2)}`, 'success');
            } catch (error) {
                showToast('è·å–è‚¡ç¥¨ä»·æ ¼å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
            }
        }

        function quickFillDemo() {
            const demos = [
                { symbol: 'AAPL', shares: 10, buyPrice: 175 },
                { symbol: 'MSFT', shares: 5, buyPrice: 380 },
                { symbol: 'NVDA', shares: 3, buyPrice: 750 },
                { symbol: 'TSLA', shares: 8, buyPrice: 220 }
            ];
            
            const demo = demos[Math.floor(Math.random() * demos.length)];
            document.getElementById('stockSymbol').value = demo.symbol;
            document.getElementById('shares').value = demo.shares;
            document.getElementById('buyPrice').value = demo.buyPrice;
            
            // Set date to 30 days ago
            const date = new Date();
            date.setDate(date.getDate() - 30);
            document.getElementById('buyDate').value = date.toISOString().split('T')[0];
        }

        function clearForm() {
            document.getElementById('stockSymbol').value = '';
            document.getElementById('shares').value = '';
            document.getElementById('buyPrice').value = '';
            document.getElementById('initialFee').value = '0';
            document.getElementById('buyDate').value = '';
        }

        async function refreshAllPrices() {
            if (portfolio.length === 0) {
                showToast('æŠ•èµ„ç»„åˆä¸ºç©º', 'error');
                return;
            }

            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = 'ğŸ”„ æ›´æ–°ä¸­... <span class="loading"></span>';

            try {
                // For Alpha Vantage free tier, we need to respect rate limits
                // Free tier: 5 API calls per minute, 500 calls per day
                
                if (portfolio.length > 5) {
                    showToast(`éœ€è¦æ›´æ–° ${portfolio.length} æ”¯è‚¡ç¥¨ï¼Œç”±äºAPIé™åˆ¶ï¼Œè¿™å¯èƒ½éœ€è¦ ${Math.ceil(portfolio.length / 5)} åˆ†é’Ÿ`, 'warning');
                }
                
                // Get unique symbols
                const symbols = [...new Set(portfolio.map(stock => stock.symbol))];
                const prices = await fetchMultiplePrices(symbols);
                
                // Update portfolio with new prices
                for (let stock of portfolio) {
                    if (prices[stock.symbol] !== null) {
                        stock.previousClose = stock.currentPrice;
                        stock.currentPrice = prices[stock.symbol];
                        stock.lastUpdate = new Date().toISOString();
                    }
                }
                
                savePortfolio();
                updateDisplay();
                lastUpdateTime = new Date();
                showToast('æ‰€æœ‰ä»·æ ¼å·²æ›´æ–°ï¼', 'success');
            } catch (error) {
                console.error('Refresh error:', error);
                showToast('æ›´æ–°å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = 'ğŸ”„ åˆ·æ–°æ‰€æœ‰ä»·æ ¼';
            }
        }

        // Execute buy more operation
        function executeBuyMore(id, additionalShares, price, feePerShare = 0) {
            const stock = portfolio.find(s => s.id === id);
            if (!stock) return;

            // Calculate purchase cost including fees
            const purchaseCost = (additionalShares * price) + (additionalShares * feePerShare);

            // Check if user has enough cash
            if (purchaseCost > cashBalance) {
                showToast(`ç°é‡‘ä½™é¢ä¸è¶³ï¼éœ€è¦ $${purchaseCost.toFixed(2)}ï¼Œä½†åªæœ‰ $${cashBalance.toFixed(2)}`, 'error');
                return;
            }

            // Calculate total fee for this transaction
            const totalFee = additionalShares * feePerShare;

            // Calculate new average buy price (including fees)
            const totalCost = (stock.shares * stock.buyPrice) + (additionalShares * price) + totalFee;
            const totalShares = stock.shares + additionalShares;
            const newAvgPrice = totalCost / totalShares;

            // Update stock data
            stock.shares = totalShares;
            stock.buyPrice = newAvgPrice;

            // Record transaction
            const transaction = {
                id: Date.now(),
                stockSymbol: stock.symbol,
                type: 'buy',
                shares: additionalShares,
                price: price,
                feePerShare: feePerShare,
                totalFee: totalFee,
                totalValue: price * additionalShares,
                realizedProfit: 0,
                date: new Date().toISOString(),
                note: 'åŠ ä»“'
            };

            transactionHistory.push(transaction);

            // Deduct cash for purchase
            cashBalance -= purchaseCost;
            saveCashBalance();

            savePortfolio();
            saveTransactionHistory();
            updateDisplay();
            showToast(`${stock.symbol} åŠ ä»“æˆåŠŸï¼æ–°æŒè‚¡: ${totalShares.toFixed(2)}è‚¡ï¼Œå¹³å‡æˆæœ¬: $${newAvgPrice.toFixed(2)} (å«æ‰‹ç»­è´¹: $${totalFee.toFixed(2)})`, 'success');
        }

        // Execute sell part operation
        function executeSellPart(id, sellShares, price, feePerShare = 0) {
            const stock = portfolio.find(s => s.id === id);
            if (!stock) return;

            // Calculate total fee for this transaction
            const totalFee = sellShares * feePerShare;
            const realizedProfit = (price - stock.buyPrice) * sellShares - totalFee;

            // Update stock data
            stock.shares -= sellShares;

            // Record transaction
            const transaction = {
                id: Date.now(),
                stockSymbol: stock.symbol,
                type: 'sell',
                shares: sellShares,
                price: price,
                feePerShare: feePerShare,
                totalFee: totalFee,
                totalValue: price * sellShares,
                realizedProfit: realizedProfit,
                date: new Date().toISOString(),
                note: 'å‡ä»“'
            };

            transactionHistory.push(transaction);
            totalRealizedProfit += realizedProfit;

            // Add cash from sale (total sale amount minus fees)
            const saleProceeds = (price * sellShares) - totalFee;
            cashBalance += saleProceeds;
            saveCashBalance();

            savePortfolio();
            saveTransactionHistory();
            updateDisplay();
            showToast(`${stock.symbol} å‡ä»“æˆåŠŸï¼å‰©ä½™æŒè‚¡: ${stock.shares.toFixed(2)}è‚¡ï¼Œå®ç°${realizedProfit >= 0 ? 'ç›ˆåˆ©' : 'äºæŸ'} $${Math.abs(realizedProfit).toFixed(2)} (å«æ‰‹ç»­è´¹: $${totalFee.toFixed(2)})`, realizedProfit >= 0 ? 'success' : 'warning');
        }

        // Execute delete (clear all) operation
        function executeDelete(id, salePrice, feePerShare = 0) {
            const stock = portfolio.find(s => s.id === id);
            if (!stock) return;

            // Calculate total fee for this transaction
            const totalFee = stock.shares * feePerShare;
            const realizedProfit = (salePrice - stock.buyPrice) * stock.shares - totalFee;

            const transaction = {
                id: Date.now(),
                stockSymbol: stock.symbol,
                type: 'sell',
                shares: stock.shares,
                price: salePrice,
                feePerShare: feePerShare,
                totalFee: totalFee,
                totalValue: salePrice * stock.shares,
                realizedProfit: realizedProfit,
                date: new Date().toISOString(),
                note: 'æ¸…ä»“'
            };

            transactionHistory.push(transaction);
            totalRealizedProfit += realizedProfit;

            // Add cash from sale (total sale amount minus fees)
            const saleProceeds = (salePrice * stock.shares) - totalFee;
            cashBalance += saleProceeds;
            saveCashBalance();

            portfolio = portfolio.filter(s => s.id !== id);
            savePortfolio();
            saveTransactionHistory();
            updateDisplay();
            showToast(`${stock.symbol} å·²æ¸…ä»“ï¼Œå®ç°${realizedProfit >= 0 ? 'ç›ˆåˆ©' : 'äºæŸ'} $${Math.abs(realizedProfit).toFixed(2)} (å«æ‰‹ç»­è´¹: $${totalFee.toFixed(2)})`, realizedProfit >= 0 ? 'success' : 'warning');
        }

        function updateDisplay() {
            const tbody = document.getElementById('portfolioBody');
            
            if (portfolio.length === 0) {
                tbody.innerHTML = `
                    <tr class="empty-state">
                        <td colspan="12">
                            <h3>ğŸ“­ æš‚æ— æŒä»“</h3>
                            <p>ä½¿ç”¨ä¸Šæ–¹è¡¨å•æ·»åŠ æ‚¨çš„ç¬¬ä¸€æ”¯è‚¡ç¥¨</p>
                            <p style="margin-top: 10px; color: #666;">æ”¯æŒç¾è‚¡å®æ—¶ä»·æ ¼è‡ªåŠ¨æ›´æ–°</p>
                        </td>
                    </tr>
                `;

                // Calculate principal (total deposits only) even when no stocks
                let totalDeposits = 0;
                let totalWithdrawals = 0;
                transactionHistory.forEach(transaction => {
                    if (transaction.type === 'cash_deposit') {
                        totalDeposits += transaction.amount;
                    } else if (transaction.type === 'cash_withdrawal') {
                        totalWithdrawals += Math.abs(transaction.amount);
                    }
                });
                const principal = totalDeposits - totalWithdrawals; // Principal = deposits - withdrawals
                const currentValue = cashBalance; // Only cash when no stocks
                const totalReturn = 0; // No stock returns when no stocks
                const returnPercent = 0; // No returns when no stocks

                updateSummary(principal, currentValue, totalReturn, returnPercent, 0, 0);
                updateChart([]);
                updateCashDisplay();
                return;
            }

            let totalInvestment = 0;
            let totalCurrentValue = 0;
            let totalDailyChange = 0;

            // Calculate total investment (principal) as total deposits only
            let totalDeposits = 0;
            let totalWithdrawals = 0;
            transactionHistory.forEach(transaction => {
                if (transaction.type === 'cash_deposit') {
                    totalDeposits += transaction.amount;
                } else if (transaction.type === 'cash_withdrawal') {
                    totalWithdrawals += Math.abs(transaction.amount);
                }
            });
            totalInvestment = totalDeposits - totalWithdrawals; // Principal = deposits - withdrawals

            // Calculate stock investment and value totals (excluding cash)
            let totalStockInvestment = 0;
            let totalStockValue = 0;
            portfolio.forEach(stock => {
                totalStockInvestment += stock.shares * stock.buyPrice;
                totalStockValue += stock.shares * stock.currentPrice;
            });

            // Total current value includes stocks + cash for portfolio distribution
            totalCurrentValue = totalStockValue + cashBalance;

            // Build table rows
            tbody.innerHTML = portfolio.map(stock => {
                const investment = stock.shares * stock.buyPrice;
                const currentValue = stock.shares * stock.currentPrice;
                const returnDollar = currentValue - investment;
                const returnPercent = ((returnDollar / investment) * 100).toFixed(2);
                const weight = ((currentValue / totalCurrentValue) * 100).toFixed(2);
                const dailyChange = stock.previousClose ? 
                    (stock.currentPrice - stock.previousClose) * stock.shares : 0;
                
                // Calculate holding days
                const buyDate = new Date(stock.buyDate);
                const today = new Date();
                const holdingDays = Math.floor((today - buyDate) / (1000 * 60 * 60 * 24));
                totalDailyChange += dailyChange;

                const returnClass = returnDollar >= 0 ? 'positive' : 'negative';
                const dailyClass = dailyChange >= 0 ? 'positive' : 'negative';
                const returnSymbol = returnDollar >= 0 ? 'â†‘' : 'â†“';

                return `
                    <tr>
                        <td><span class="stock-symbol">${stock.symbol}</span></td>
                        <td>${stock.companyName}</td>
                        <td>${stock.shares.toFixed(2)}</td>
                        <td>${stock.buyPrice.toFixed(2)}</td>
                        <td>${stock.currentPrice.toFixed(2)}</td>
                        <td>${investment.toFixed(2)}</td>
                        <td>${currentValue.toFixed(2)}</td>
                        <td class="${returnClass}">${returnSymbol} ${Math.abs(returnDollar).toFixed(2)}</td>
                        <td class="${returnClass}">${returnSymbol} ${Math.abs(returnPercent)}%</td>
                        <td><strong>${weight}%</strong></td>
                        <td>${holdingDays} å¤©</td>
                        <td>
                            <div class="action-buttons">
                                <button class="buy-more-btn" onclick="buyMoreStock(${stock.id})" title="åŠ ä»“">ğŸ“ˆ åŠ ä»“</button>
                                <button class="sell-part-btn" onclick="sellPartStock(${stock.id})" title="å‡ä»“">ğŸ“‰ å‡ä»“</button>
                                <button class="delete-btn" onclick="deleteStock(${stock.id})" title="æ¸…ä»“">ğŸ—‘ï¸ æ¸…ä»“</button>
                            </div>
                        </td>
                    </tr>
                    <tr class="stock-chart-row">
                        <td colspan="12">
                            <div class="stock-detail-header" onclick="toggleStockDetails(${stock.id})">
                                <span class="detail-toggle-icon" id="toggle-${stock.id}">â–¼</span>
                                <span class="detail-title">${stock.symbol} è¯¦ç»†ä¿¡æ¯ä¸èµ°åŠ¿å›¾</span>
                                <span class="detail-subtitle">ç‚¹å‡»å±•å¼€/æ”¶èµ·</span>
                            </div>
                            <div class="stock-detail-container" id="details-${stock.id}" style="display: none;">
                                <div class="stock-specs">
                                    <h4>${stock.symbol} è¯¦ç»†ä¿¡æ¯</h4>
                                    <div class="specs-grid" id="specs-${stock.id}">
                                        <div class="spec-section">
                                            <div class="spec-item">
                                                <span class="spec-label">å‰æ”¶ç›˜</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">å¼€ç›˜</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">æ—¥æ³¢åŠ¨</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">52å‘¨æ³¢åŠ¨</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">æˆäº¤é‡</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                        </div>
                                        <div class="spec-section">
                                            <div class="spec-item">
                                                <span class="spec-label">å¸‚å€¼</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">Beta (5å¹´)</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">å¸‚ç›ˆç‡ (TTM)</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">æ¯è‚¡æ”¶ç›Š (TTM)</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                            <div class="spec-item">
                                                <span class="spec-label">è´§å¸</span>
                                                <span class="spec-value loading-data">åŠ è½½ä¸­...</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="stock-chart-container">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                        <h4>${stock.symbol} ä»·æ ¼èµ°åŠ¿</h4>
                                        <div class="time-selector light" id="stockTimeSelector-${stock.id}">
                                            <button class="time-btn light" data-period="1D" onclick="onStockTimeRangeChange('${stock.id}', '1D')">æ—¥çº¿</button>
                                            <button class="time-btn light" data-period="1W" onclick="onStockTimeRangeChange('${stock.id}', '1W')">å‘¨çº¿</button>
                                            <button class="time-btn light active" data-period="1M" onclick="onStockTimeRangeChange('${stock.id}', '1M')">æœˆçº¿</button>
                                            <button class="time-btn light" data-period="3M" onclick="onStockTimeRangeChange('${stock.id}', '3M')">å­£çº¿</button>
                                            <button class="time-btn light" data-period="6M" onclick="onStockTimeRangeChange('${stock.id}', '6M')">åŠå¹´çº¿</button>
                                            <button class="time-btn light" data-period="YTD" onclick="onStockTimeRangeChange('${stock.id}', 'YTD')">ä»Šå¹´</button>
                                        </div>
                                    </div>
                                    <div class="chart-wrapper">
                                        <canvas id="chart-${stock.id}"></canvas>
                                    </div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');

            // Total returns should only reflect stock performance, not cash changes
            const totalReturn = totalStockValue - totalStockInvestment;
            const totalReturnPercent = totalStockInvestment > 0 ? (totalReturn / totalStockInvestment) * 100 : 0;

            updateSummary(totalInvestment, totalCurrentValue, totalReturn, totalReturnPercent, totalDailyChange, portfolio.length);
            updateChart(portfolio);

            // Update portfolio trend chart if we have transaction history
            if (transactionHistory.length > 0) {
                setTimeout(() => updatePortfolioTrendChart(), 1000);
            }

            // Render individual stock charts with proper timing
            requestAnimationFrame(() => {
                setTimeout(() => {
                    portfolio.forEach(stock => {
                        renderStockChart(stock);
                    });
                }, 200); // Increased delay to ensure DOM is fully updated
            });

            // Update last update time
            if (lastUpdateTime) {
                document.getElementById('lastUpdate').textContent =
                    new Date(lastUpdateTime).toLocaleString('zh-CN');
            }
        }

        function updateSummary(investment, currentValue, totalReturn, returnPercentage, dailyChange, stockCount) {
            document.getElementById('totalInvestment').textContent = `${investment.toFixed(2)}`;
            document.getElementById('currentValue').textContent = `${currentValue.toFixed(2)}`;
            document.getElementById('stockCount').textContent = stockCount.toString();

            // Calculate total fees from transaction history
            const totalFees = transactionHistory.reduce((sum, transaction) => {
                return sum + (transaction.totalFee || 0);
            }, 0);
            document.getElementById('totalFees').textContent = `$${totalFees.toFixed(2)}`;

            const returnElement = document.getElementById('totalReturn');
            const returnCard = document.getElementById('totalReturnCard');

            const returnSymbol = totalReturn >= 0 ? 'â†‘' : 'â†“';

            returnElement.textContent = `${returnSymbol} ${Math.abs(totalReturn).toFixed(2)}`;

            if (totalReturn >= 0) {
                returnCard.classList.add('profit');
                returnCard.classList.remove('loss');
            } else {
                returnCard.classList.add('loss');
                returnCard.classList.remove('profit');
            }

            // Update cash balance display
            updateCashDisplay();
        }

        function updateCashDisplay() {
            document.getElementById('cashBalance').textContent = `$${cashBalance.toFixed(2)}`;
            document.getElementById('currentCashDisplay').textContent = cashBalance.toFixed(2);
        }

        function initChart() {
            const ctx = document.getElementById('portfolioChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: [
                            '#FF6384',
                            '#36A2EB',
                            '#FFCE56',
                            '#4BC0C0',
                            '#9966FF',
                            '#FF9F40',
                            '#FF6384',
                            '#C9CBCF',
                            '#4BC0C0',
                            '#FF6384'
                        ],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                padding: 15,
                                font: {
                                    size: 12
                                },
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const value = data.datasets[0].data[i];
                                            const percentage = data.datasets[0].percentages ? data.datasets[0].percentages[i] : '';
                                            return {
                                                text: `${label}: ${percentage}%`,
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                hidden: false,
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = '$' + context.parsed.toFixed(2);
                                    const percentage = context.dataset.percentages ? 
                                        context.dataset.percentages[context.dataIndex] + '%' : '';
                                    return `${label}: ${value} (${percentage})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateChart(stocks) {
            if (!chartInstance) return;

            let totalValue = 0;
            stocks.forEach(stock => {
                totalValue += stock.shares * stock.currentPrice;
            });

            // Add cash balance to total value
            totalValue += cashBalance;

            const labels = [];
            const data = [];
            const percentages = [];

            // Add stock holdings
            stocks.forEach(stock => {
                const value = stock.shares * stock.currentPrice;
                const percentage = ((value / totalValue) * 100).toFixed(1);

                labels.push(stock.symbol);
                data.push(value);
                percentages.push(percentage);
            });

            // Handle case when no stocks are held
            if (stocks.length === 0) {
                // Show 100% principal when no stocks
                if (totalValue > 0) {
                    labels.push('æœ¬é‡‘');
                    data.push(totalValue);
                    percentages.push('100.0');
                } else {
                    // If no cash and no stocks, show empty chart
                    chartInstance.data.labels = [];
                    chartInstance.data.datasets[0].data = [];
                    chartInstance.data.datasets[0].percentages = [];
                    chartInstance.update();
                    return;
                }
            } else {
                // Add cash balance to chart if there's any cash and we have stocks
                if (cashBalance > 0) {
                    const cashPercentage = ((cashBalance / totalValue) * 100).toFixed(1);
                    labels.push('ç°é‡‘');
                    data.push(cashBalance);
                    percentages.push(cashPercentage);
                }
            }

            chartInstance.data.labels = labels;
            chartInstance.data.datasets[0].data = data;
            chartInstance.data.datasets[0].percentages = percentages;
            chartInstance.update();
        }

        // Initialize Portfolio Trend Chart
        function initPortfolioTrendChart() {
            const ctx = document.getElementById('portfolioTrendChart').getContext('2d');
            portfolioTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å½“å‰å¸‚å€¼',
                        data: [],
                        borderColor: '#4F46E5',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#4F46E5',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    }, {
                        label: 'æœ¬é‡‘',
                        data: [],
                        borderColor: '#EF4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        pointBackgroundColor: '#EF4444',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 15,
                                padding: 20,
                                font: { size: 14, weight: '500' }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#4F46E5',
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12,
                            callbacks: {
                                title: function(context) {
                                    return 'æ—¥æœŸ: ' + context[0].label;
                                },
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = '$' + context.parsed.y.toFixed(2);
                                    return `${label}: ${value}`;
                                },
                                afterBody: function(context) {
                                    if (context.length === 2) {
                                        const portfolioValue = context[0].parsed.y;
                                        const costValue = context[1].parsed.y;
                                        const profit = portfolioValue - costValue;
                                        const profitPercent = costValue > 0 ? ((profit / costValue) * 100).toFixed(2) : '0.00';
                                        return [``, `ç›ˆäº: ${profit >= 0 ? '+' : ''}$${profit.toFixed(2)}`, `æ”¶ç›Šç‡: ${profit >= 0 ? '+' : ''}${profitPercent}%`];
                                    }
                                    return [];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            },
                            ticks: {
                                font: { size: 12 },
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                font: { size: 12 },
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            }
                        }
                    }
                }
            });
        }

        // Calculate historical portfolio values based on transactions and REAL historical prices
        async function calculateHistoricalPortfolioValues() {
            if (transactionHistory.length === 0) {
                return [];
            }

            // Sort transactions by date
            const sortedTransactions = [...transactionHistory].sort((a, b) => new Date(a.date) - new Date(b.date));

            // Get date range - start from first transaction, go to today
            const startDate = new Date(sortedTransactions[0].date);
            const endDate = new Date();

            // Get all unique symbols that have been traded
            const allSymbols = [...new Set(sortedTransactions.map(t => t.stockSymbol))];

            // Fetch historical price data for all symbols
            const historicalPriceData = new Map();

            showToast('æ­£åœ¨è·å–å†å²ä»·æ ¼æ•°æ®...', 'success');

            for (const symbol of allSymbols) {
                try {
                    const priceHistory = await fetchHistoricalPricesForSymbol(symbol, startDate, endDate);
                    if (priceHistory && priceHistory.length > 0) {
                        historicalPriceData.set(symbol, priceHistory);
                        console.log(`è·å– ${symbol} å†å²ä»·æ ¼æ•°æ®: ${priceHistory.length} ä¸ªæ•°æ®ç‚¹`);
                    } else {
                        console.warn(`æ— æ³•è·å– ${symbol} å†å²ä»·æ ¼æ•°æ®ï¼Œè·³è¿‡è¯¥è‚¡ç¥¨çš„ç»„åˆèµ°åŠ¿å›¾è®¡ç®—`);
                        showToast(`âš ï¸ ${symbol} æ— å†å²æ•°æ®ï¼Œç»„åˆèµ°åŠ¿å›¾å¯èƒ½ä¸å®Œæ•´`, 'warning');
                        // ä¸æ·»åŠ ä»»ä½•æ•°æ®ï¼Œç›´æ¥è·³è¿‡è¿™ä¸ªè‚¡ç¥¨
                    }
                } catch (error) {
                    console.warn(`æ— æ³•è·å– ${symbol} å†å²ä»·æ ¼æ•°æ®:`, error);
                    showToast(`âŒ ${symbol} å†å²æ•°æ®è·å–å¤±è´¥ï¼Œè·³è¿‡è¯¥è‚¡ç¥¨`, 'error');
                    // ä¸ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼Œç›´æ¥è·³è¿‡
                }
            }

            // Build daily portfolio snapshots
            const historicalValues = [];
            let currentHoldings = new Map(); // symbol -> { shares, avgCost }
            let currentCashBalance = 0; // Track cash balance over time

            // Process each day from start to end
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toISOString().split('T')[0];

                // Apply any transactions that occurred on this date
                const dayTransactions = sortedTransactions.filter(t =>
                    t.date.split('T')[0] === dateStr
                );

                dayTransactions.forEach(transaction => {
                    if (transaction.type === 'cash_deposit') {
                        // Cash deposit increases cash balance
                        currentCashBalance += transaction.amount;
                    } else if (transaction.type === 'cash_withdrawal') {
                        // Cash withdrawal decreases cash balance
                        currentCashBalance -= Math.abs(transaction.amount);
                    } else if (transaction.stockSymbol) {
                        // Stock transactions
                        const symbol = transaction.stockSymbol;
                        const holding = currentHoldings.get(symbol) || { shares: 0, avgCost: 0 };

                        if (transaction.type === 'buy') {
                            // Calculate new average cost
                            const totalCost = (holding.shares * holding.avgCost) + transaction.totalValue;
                            const totalShares = holding.shares + transaction.shares;
                            holding.avgCost = totalShares > 0 ? totalCost / totalShares : transaction.price;
                            holding.shares = totalShares;
                            // Buying stocks reduces cash balance
                            currentCashBalance -= transaction.totalValue;
                        } else if (transaction.type === 'sell') {
                            holding.shares -= transaction.shares;
                            // Selling stocks increases cash balance
                            currentCashBalance += transaction.totalValue;
                            // Average cost stays the same when selling
                            if (holding.shares <= 0) {
                                currentHoldings.delete(symbol);
                                return;
                            }
                        }

                        if (holding.shares > 0) {
                            currentHoldings.set(symbol, holding);
                        }
                    }
                });

                // Skip weekends for cleaner chart
                if (d.getDay() === 0 || d.getDay() === 6) continue;

                // Calculate total asset value for this date (stocks + cash)
                if (currentHoldings.size > 0 || currentCashBalance > 0) {
                    let stockValue = 0;
                    let stockCost = 0;
                    let hasAllPrices = true;

                    // Calculate stock values and costs
                    for (const [symbol, holding] of currentHoldings) {
                        const priceHistory = historicalPriceData.get(symbol);
                        const dayPrice = findPriceForDate(priceHistory, dateStr);

                        if (dayPrice && dayPrice > 0) {
                            stockValue += holding.shares * dayPrice;
                            stockCost += holding.shares * holding.avgCost;
                        } else {
                            hasAllPrices = false;
                            break;
                        }
                    }

                    // Calculate total principal (deposits - withdrawals) up to this date
                    let totalPrincipal = 0;
                    sortedTransactions.forEach(t => {
                        if (new Date(t.date) <= d) {
                            if (t.type === 'cash_deposit') {
                                totalPrincipal += t.amount;
                            } else if (t.type === 'cash_withdrawal') {
                                totalPrincipal -= Math.abs(t.amount);
                            }
                        }
                    });

                    // Include cash balance in total asset value
                    const totalAssetValue = stockValue + Math.max(0, currentCashBalance);
                    // Total cost should be just the principal (cash investments only)
                    const totalCost = Math.max(0, totalPrincipal);

                    if ((currentHoldings.size === 0 || hasAllPrices) && totalAssetValue > 0) {
                        historicalValues.push({
                            date: dateStr,
                            portfolioValue: totalAssetValue, // Total asset value (stocks + cash)
                            totalCost: totalCost, // Total invested cost (stock costs + cash principal)
                            holdings: Array.from(currentHoldings.entries()),
                            cashBalance: Math.max(0, currentCashBalance)
                        });
                    }
                }
            }

            return historicalValues;
        }

        // Fetch historical data from Financial Modeling Prep API
        async function fetchHistoricalFromFMP(symbol, startDate, endDate) {
            const dateFrom = startDate.toISOString().split('T')[0];
            const dateTo = endDate.toISOString().split('T')[0];

            try {
                // Using Financial Modeling Prep free tier with better error handling
                const url = `https://financialmodelingprep.com/api/v3/historical-price-full/${symbol}?from=${dateFrom}&to=${dateTo}&apikey=demo`;
                console.log(`Fetching FMP data: ${url}`);

                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    },
                    // Add timeout to prevent hanging requests
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    console.error(`FMP API Error: ${response.status} - ${response.statusText}`);
                    throw new Error(`FMP HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('FMP Response:', data);

                // Check for API error messages
                if (data.error || data.message) {
                    throw new Error(`FMP API Error: ${data.error || data.message}`);
                }

                if (!data.historical || !Array.isArray(data.historical) || data.historical.length === 0) {
                    throw new Error('No historical data available from FMP');
                }

                const historicalData = data.historical.map(item => ({
                    date: item.date,
                    price: parseFloat(item.close) || 0
                })).filter(item => item.price > 0).sort((a, b) => new Date(a.date) - new Date(b.date));

                if (historicalData.length === 0) {
                    throw new Error('No valid historical data points from FMP');
                }

                return historicalData;

            } catch (error) {
                console.error(`FMP fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // Fetch historical data from Finnhub
        async function fetchHistoricalFromFinnhub(symbol, startDate, endDate) {
            try {
                // Convert dates to Unix timestamps (Finnhub requirement)
                const from = Math.floor(startDate.getTime() / 1000);
                const to = Math.floor(endDate.getTime() / 1000);

                const url = `https://finnhub.io/api/v1/stock/candle?symbol=${symbol}&resolution=D&from=${from}&to=${to}&token=${FINNHUB_API_KEY}`;

                console.log(`Fetching Finnhub data: ${url}`);

                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'X-Finnhub-Token': FINNHUB_API_KEY
                    },
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    console.error(`Finnhub API Error: ${response.status} - ${response.statusText}`);
                    throw new Error(`Finnhub HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Finnhub Response:', data);

                // Check for API error
                if (data.s === 'no_data') {
                    throw new Error('No data available for this symbol');
                }

                if (data.s !== 'ok') {
                    throw new Error(`Finnhub API Error: ${data.s}`);
                }

                if (!data.c || !data.t || data.c.length === 0) {
                    throw new Error('Invalid Finnhub response format');
                }

                // Convert Finnhub format to our format
                const historicalData = [];
                for (let i = 0; i < data.c.length; i++) {
                    const date = new Date(data.t[i] * 1000); // Convert Unix timestamp to Date
                    const price = parseFloat(data.c[i]); // Close price

                    if (!isNaN(price) && price > 0) {
                        historicalData.push({
                            date: date.toISOString().split('T')[0], // YYYY-MM-DD format
                            price: price
                        });
                    }
                }

                return historicalData.sort((a, b) => new Date(a.date) - new Date(b.date));

            } catch (error) {
                console.error(`Finnhub fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // Fetch real historical prices for a symbol using multiple APIs
        // Fetch historical data from Yahoo Finance (free alternative)
        async function fetchHistoricalFromYahoo(symbol, startDate, endDate) {
            try {
                const period1 = Math.floor(startDate.getTime() / 1000);
                const period2 = Math.floor(endDate.getTime() / 1000);

                // Use CORS proxy for Yahoo Finance
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const yahooUrl = `https://query1.finance.yahoo.com/v7/finance/download/${symbol}?period1=${period1}&period2=${period2}&interval=1d&events=history&includeAdjustedClose=true`;
                const url = proxyUrl + encodeURIComponent(yahooUrl);

                console.log(`Fetching Yahoo historical data via proxy: ${symbol}`);

                const response = await fetch(url, {
                    method: 'GET',
                    signal: AbortSignal.timeout(15000) // Increase timeout for proxy
                });

                if (!response.ok) {
                    throw new Error(`Yahoo HTTP ${response.status}`);
                }

                const csvText = await response.text();

                // Check if response is actually CSV data
                if (!csvText || csvText.includes('error') || csvText.includes('404')) {
                    throw new Error('Invalid Yahoo response or symbol not found');
                }

                const lines = csvText.trim().split('\n');

                if (lines.length < 2) {
                    throw new Error('No historical data in Yahoo response');
                }

                const historicalData = [];
                for (let i = 1; i < lines.length; i++) {
                    const columns = lines[i].split(',');
                    if (columns.length < 5) continue; // Skip invalid lines

                    const [date, , , , close] = columns;
                    const price = parseFloat(close);

                    if (!isNaN(price) && price > 0 && date) {
                        historicalData.push({
                            date: date,
                            price: price
                        });
                    }
                }

                if (historicalData.length === 0) {
                    throw new Error('No valid price data found in Yahoo response');
                }

                return historicalData.sort((a, b) => new Date(a.date) - new Date(b.date));

            } catch (error) {
                console.error(`Yahoo historical fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // Fetch from Polygon.io (another free option)
        async function fetchHistoricalFromPolygon(symbol, startDate, endDate) {
            try {
                const from = startDate.toISOString().split('T')[0];
                const to = endDate.toISOString().split('T')[0];
                // Using free tier - limited but may work
                const url = `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/1/day/${from}/${to}?adjusted=true&sort=asc&apikey=demo`;

                console.log(`Fetching Polygon data: ${url}`);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    throw new Error(`Polygon HTTP ${response.status}`);
                }

                const data = await response.json();

                if (!data.results || !Array.isArray(data.results)) {
                    throw new Error('No results from Polygon');
                }

                return data.results.map(item => ({
                    date: new Date(item.t).toISOString().split('T')[0],
                    price: item.c
                })).sort((a, b) => new Date(a.date) - new Date(b.date));

            } catch (error) {
                console.error(`Polygon fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // Alpha Vantage backup for historical data
        async function fetchHistoricalFromAlphaVantage(symbol, startDate, endDate) {
            try {
                const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&apikey=demo&outputsize=full`;

                console.log(`Fetching Alpha Vantage historical data: ${symbol}`);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    throw new Error(`Alpha Vantage HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data['Note'] || data['Information']) {
                    throw new Error('Alpha Vantage API limit reached');
                }

                if (!data['Time Series (Daily)']) {
                    throw new Error('No historical data found in Alpha Vantage response');
                }

                const timeSeries = data['Time Series (Daily)'];
                const priceHistory = [];

                // Convert to our format
                for (const [date, dayData] of Object.entries(timeSeries)) {
                    const dateObj = new Date(date);
                    if (dateObj >= startDate && dateObj <= endDate) {
                        priceHistory.push({
                            date: date,
                            price: parseFloat(dayData['4. close'])
                        });
                    }
                }

                return priceHistory.sort((a, b) => new Date(a.date) - new Date(b.date));

            } catch (error) {
                console.error(`Alpha Vantage historical fetch error for ${symbol}:`, error);
                throw error;
            }
        }

        // ä½¿ç”¨APIè·å–å†å²æ•°æ®ï¼ˆæŒ‰å‘¨æœŸï¼‰
        async function fetchHistoricalFromLocalAPIByPeriod(symbol, period = '1M') {
            try {
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const url = `${apiUrl}/api/history/${symbol}?period=${period}`;
                console.log(`ğŸ”„ æ­£åœ¨ä»APIè·å– ${symbol} å†å²æ•°æ® (${period}): ${url}`);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    // è½¬æ¢ä¸ºæœŸæœ›çš„æ ¼å¼
                    const priceHistory = data.data.map(item => ({
                        date: item.date,
                        price: item.close
                    }));

                    console.log(`âœ… æœ¬åœ°APIè·å–åˆ° ${symbol} å†å²æ•°æ® (${period}): ${priceHistory.length} ä¸ªæ•°æ®ç‚¹`);
                    return priceHistory;
                } else {
                    console.warn(`âš ï¸ æœ¬åœ°APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸:`, data);
                    return null;
                }
            } catch (error) {
                console.error(`âŒ æœ¬åœ°APIè·å– ${symbol} å†å²æ•°æ®å¤±è´¥:`, error);
                return null;
            }
        }

        // ä½¿ç”¨æœ¬åœ°APIè·å–å†å²æ•°æ®ï¼ˆæŒ‰æ—¥æœŸèŒƒå›´ï¼‰- ä¿æŒå‘åå…¼å®¹
        async function fetchHistoricalFromLocalAPI(symbol, startDate, endDate) {
            try {
                const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                const days = Math.min(Math.max(daysDiff, 7), 365); // é™åˆ¶åœ¨7-365å¤©ä¹‹é—´

                // Convert days to period for new API
                let period = '1M';
                if (days <= 1) period = '1D';
                else if (days <= 7) period = '1W';
                else if (days <= 30) period = '1M';
                else if (days <= 90) period = '3M';
                else if (days <= 180) period = '6M';
                else period = 'YTD';

                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                const url = `${apiUrl}/api/history/${symbol}?period=${period}`;
                console.log(`ğŸ”„ æ­£åœ¨ä»APIè·å– ${symbol} å†å²æ•°æ®: ${url}`);

                const response = await fetch(url, {
                    signal: AbortSignal.timeout(10000)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.success && data.data && data.data.length > 0) {
                    // è½¬æ¢ä¸ºæœŸæœ›çš„æ ¼å¼
                    const priceHistory = data.data.map(item => ({
                        date: item.date,
                        price: item.close
                    })).filter(item => {
                        const itemDate = new Date(item.date);
                        return itemDate >= startDate && itemDate <= endDate;
                    });

                    console.log(`âœ… æœ¬åœ°APIè·å–åˆ° ${symbol} å†å²æ•°æ®: ${priceHistory.length} ä¸ªæ•°æ®ç‚¹`);
                    return priceHistory;
                } else {
                    console.warn(`âš ï¸ æœ¬åœ°APIè¿”å›æ•°æ®æ ¼å¼å¼‚å¸¸:`, data);
                    return null;
                }
            } catch (error) {
                console.error(`âŒ æœ¬åœ°APIè·å– ${symbol} å†å²æ•°æ®å¤±è´¥:`, error);
                return null;
            }
        }

        async function fetchHistoricalPricesForSymbol(symbol, startDate, endDate) {
            const historicalAPIs = [
                { name: 'æœ¬åœ°APIæœåŠ¡', fetch: () => fetchHistoricalFromLocalAPI(symbol, startDate, endDate) },
                { name: 'Yahoo Finance', fetch: () => fetchHistoricalFromYahoo(symbol, startDate, endDate) },
                { name: 'Finnhub', fetch: () => fetchHistoricalFromFinnhub(symbol, startDate, endDate) },
                { name: 'Alpha Vantage', fetch: () => fetchHistoricalFromAlphaVantage(symbol, startDate, endDate) }
            ];

            for (const api of historicalAPIs) {
                try {
                    console.log(`ğŸ”„ å°è¯•è·å– ${symbol} å†å²æ•°æ® - ${api.name}`);
                    showToast(`ğŸ”„ æ­£åœ¨ä» ${api.name} è·å– ${symbol} æ•°æ®...`, 'info');

                    const priceHistory = await api.fetch();

                    if (priceHistory && priceHistory.length > 0) {
                        console.log(`âœ… ${api.name} - è·å–åˆ° ${symbol} ${priceHistory.length} ä¸ªå†å²æ•°æ®ç‚¹`);
                        console.log(`é¦–ä¸ªæ•°æ®ç‚¹:`, priceHistory[0]);
                        console.log(`æœ€åæ•°æ®ç‚¹:`, priceHistory[priceHistory.length - 1]);
                        showToast(`âœ… ${symbol} çœŸå®å†å²æ•°æ®æ¥è‡ª ${api.name} (${priceHistory.length}æ¡)`, 'success');
                        return priceHistory;
                    } else {
                        console.warn(`âš ï¸ ${api.name} - ${symbol} è¿”å›ç©ºæ•°æ®`);
                    }
                } catch (error) {
                    console.error(`âŒ ${api.name} - ${symbol} å†å²æ•°æ®è·å–å¤±è´¥:`, error);
                    showToast(`âŒ ${api.name} è·å–å¤±è´¥: ${error.message}`, 'error');
                    continue;
                }
            }

            // If all APIs fail, return null
            console.warn(`æ‰€æœ‰å†å²æ•°æ®APIå¤±è´¥ï¼Œ${symbol} æ— æ³•è·å–æ•°æ®`);
            showToast(`âš ï¸ ${symbol} æ— å¯ç”¨å†å²æ•°æ®`, 'warning');
            return null;
        }

        // Generate realistic price history with proper market behavior and more variation
        function generateRealisticPriceHistory(symbol, startDate, endDate) {
            const priceHistory = [];

            // Get current price as end point
            const stock = portfolio.find(s => s.symbol === symbol);
            const currentPrice = stock?.currentPrice || 100;

            // Calculate number of days
            const totalDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));

            // Create more realistic price movements based on symbol characteristics
            const dailyVolatility = getSymbolVolatility(symbol);

            // Start with more variable starting price
            const startPrice = currentPrice * (0.6 + Math.random() * 0.8); // More variation: 60%-140% of current
            let price = startPrice;

            // Calculate overall trend (but allow for more random walks)
            const totalReturn = (currentPrice - startPrice) / startPrice;
            const baseDailyTrend = totalReturn / totalDays;

            // Track momentum and trend changes for more realistic movements
            let momentum = 0;
            let trendDirection = Math.random() > 0.5 ? 1 : -1; // Start with random trend
            const momentumDecay = 0.92; // Slightly faster decay
            let daysInCurrentTrend = 0;

            for (let i = 0; i <= totalDays; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);

                // Skip weekends
                if (date.getDay() !== 0 && date.getDay() !== 6) {
                    // Calculate progress toward end
                    const progress = i / totalDays;

                    // Occasionally change trend direction for more realistic movement
                    daysInCurrentTrend++;
                    if (daysInCurrentTrend > 5 && Math.random() < 0.15) { // 15% chance to change trend after 5 days
                        trendDirection *= -1;
                        daysInCurrentTrend = 0;
                    }

                    // Generate more varied daily changes
                    const randomShock = (Math.random() - 0.5) * 2; // -1 to 1
                    const trendComponent = baseDailyTrend + (trendDirection * dailyVolatility * 0.3);
                    const dailyChange = trendComponent + (randomShock * dailyVolatility);

                    // Add momentum effect with more variation
                    momentum = momentum * momentumDecay + dailyChange * (0.2 + Math.random() * 0.3);
                    let totalChange = dailyChange + momentum * (0.1 + Math.random() * 0.2);

                    // Add market cycles - some periods of higher/lower volatility
                    const cyclePosition = (i / totalDays) * 4 * Math.PI; // 2 full cycles
                    const volatilityMultiplier = 1 + 0.3 * Math.sin(cyclePosition + Math.random());
                    totalChange *= volatilityMultiplier;

                    // Apply change
                    price = price * (1 + totalChange);

                    // Add more frequent larger moves for realism
                    if (Math.random() < 0.08) { // 8% chance of larger move
                        const bigMove = (Math.random() - 0.5) * dailyVolatility * (2 + Math.random() * 3);
                        price = price * (1 + bigMove);
                    }

                    // Ensure price stays within reasonable bounds
                    price = Math.max(price, currentPrice * 0.3);
                    price = Math.min(price, currentPrice * 2.0);

                    // For the final portion, gradually converge to current price (but not too rigidly)
                    if (progress > 0.9) {
                        const convergence = Math.pow((progress - 0.9) / 0.1, 2); // Quadratic convergence
                        const targetPrice = currentPrice * (0.95 + Math.random() * 0.1); // Slight variation from exact current price
                        price = price * (1 - convergence) + targetPrice * convergence;
                    }

                    priceHistory.push({
                        date: date.toISOString().split('T')[0],
                        price: Math.round(price * 100) / 100 // Round to 2 decimal places
                    });
                }
            }

            return priceHistory;
        }

        // Find price for a specific date
        function findPriceForDate(priceHistory, targetDate) {
            if (!priceHistory || priceHistory.length === 0) return null;

            // Find exact match first
            const exactMatch = priceHistory.find(p => p.date === targetDate);
            if (exactMatch) return exactMatch.price;

            // Find closest date (for weekends, use previous trading day)
            const targetDateObj = new Date(targetDate);
            let closest = null;
            let smallestDiff = Infinity;

            for (const priceData of priceHistory) {
                const priceDate = new Date(priceData.date);
                const diff = Math.abs(targetDateObj - priceDate);

                // Prefer earlier dates for weekends
                if (priceDate <= targetDateObj && diff < smallestDiff) {
                    closest = priceData;
                    smallestDiff = diff;
                }
            }

            return closest ? closest.price : priceHistory[priceHistory.length - 1]?.price;
        }

        // Handle time range change
        // Handle Robinhood-style time selector for portfolio trend
        function selectTimeRange(period) {
            // Update button states
            const selector = document.getElementById('portfolioTimeSelector');
            const buttons = selector.querySelectorAll('.time-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.period === period) {
                    btn.classList.add('active');
                }
            });

            // Update current time range and refresh chart
            currentTimeRange = period;

            // Use cached data for fast switching if available
            if (rawHistoricalData.length > 0) {
                refreshWithCachedData();
                showToast(`å·²åˆ‡æ¢åˆ°${getTimeRangeDisplayName(currentTimeRange)}è§†å›¾`, 'success');
            } else {
                updatePortfolioTrendChart();
            }
        }

        function onTimeRangeChange() {
            const selector = document.getElementById('timeRangeSelector');
            currentTimeRange = selector.value;

            // Use cached data for fast switching if available
            if (rawHistoricalData.length > 0) {
                refreshWithCachedData();
                showToast(`å·²åˆ‡æ¢åˆ°${getTimeRangeDisplayName(currentTimeRange)}è§†å›¾`, 'success');
            } else {
                updatePortfolioTrendChart();
            }
        }

        // Get display name for time range
        function getTimeRangeDisplayName(timeRange) {
            const names = {
                '1D': 'æ—¥çº¿',
                '1W': 'å‘¨çº¿',
                '1M': 'æœˆçº¿',
                '3M': 'å­£çº¿',
                '6M': 'åŠå¹´çº¿',
                'YTD': 'ä»Šå¹´åˆ°ç°åœ¨',
                '1Y': 'å¹´çº¿'
            };
            return names[timeRange] || timeRange;
        }

        // Aggregate data based on time range - fills in missing periods with interpolated data
        function aggregateDataByTimeRange(dailyData, timeRange) {
            if (!dailyData || dailyData.length === 0) return [];

            const now = new Date();
            const result = [];

            // All time ranges show approximately the same time span, but with different granularity
            switch (timeRange) {
                case '1D':
                    // Daily: Show last 15 days
                    return dailyData.slice(-15);

                case '1W':
                    // Weekly: Show last 15 weeks
                    for (let i = 14; i >= 0; i--) {
                        const weekEnd = new Date(now);
                        weekEnd.setDate(now.getDate() - (i * 7));

                        // Find the Friday of this week
                        const dayOfWeek = weekEnd.getDay();
                        const daysToFriday = dayOfWeek === 0 ? -2 : (5 - dayOfWeek);
                        weekEnd.setDate(weekEnd.getDate() + daysToFriday);

                        // Find closest data point for this week
                        const weekData = findClosestDataPoint(dailyData, weekEnd);
                        if (weekData) {
                            result.push({
                                ...weekData,
                                date: weekEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case '1M':
                    // Monthly: Show last 15 months
                    for (let i = 14; i >= 0; i--) {
                        const monthEnd = new Date(now.getFullYear(), now.getMonth() - i + 1, 0);

                        // Find closest data point for this month
                        const monthData = findClosestDataPoint(dailyData, monthEnd);
                        if (monthData) {
                            result.push({
                                ...monthData,
                                date: monthEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case '3M':
                    // Quarterly: Show last 15 quarters (3.75 years)
                    for (let i = 14; i >= 0; i--) {
                        const quarterEnd = new Date(now.getFullYear(), now.getMonth() - (i * 3) + 1, 0);

                        const quarterData = findClosestDataPoint(dailyData, quarterEnd);
                        if (quarterData) {
                            result.push({
                                ...quarterData,
                                date: quarterEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case '6M':
                    // Half-yearly: Show last 15 half-years (7.5 years)
                    for (let i = 14; i >= 0; i--) {
                        const halfYearEnd = new Date(now.getFullYear(), now.getMonth() - (i * 6) + 1, 0);

                        const halfYearData = findClosestDataPoint(dailyData, halfYearEnd);
                        if (halfYearData) {
                            result.push({
                                ...halfYearData,
                                date: halfYearEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case 'YTD':
                    // Year-to-date: Monthly from January to current month, fill to 15 points
                    const currentYear = now.getFullYear();
                    const monthsThisYear = now.getMonth() + 1; // 0-based to 1-based

                    // If less than 15 months available, include previous year months
                    const totalMonths = Math.max(15, monthsThisYear);
                    for (let i = totalMonths - 1; i >= 0; i--) {
                        const monthEnd = new Date(currentYear, now.getMonth() - i + 1, 0);

                        const monthData = findClosestDataPoint(dailyData, monthEnd);
                        if (monthData && result.length < 15) {
                            result.push({
                                ...monthData,
                                date: monthEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                case '1Y':
                    // Yearly: Show last 15 years
                    for (let i = 14; i >= 0; i--) {
                        const yearEnd = new Date(now.getFullYear() - i, 11, 31); // December 31st

                        const yearData = findClosestDataPoint(dailyData, yearEnd);
                        if (yearData) {
                            result.push({
                                ...yearData,
                                date: yearEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                default:
                    return dailyData;
            }

            return result.filter(item => item !== null);
        }

        // Find the closest data point to a target date (within reasonable range)
        function findClosestDataPoint(dailyData, targetDate) {
            if (!dailyData || dailyData.length === 0) return null;

            let closest = null;
            let smallestDiff = Infinity;
            const maxDiffDays = 45; // Maximum 45 days difference

            for (const dataPoint of dailyData) {
                const dataDate = new Date(dataPoint.date);
                const diff = Math.abs(targetDate - dataDate);
                const diffDays = diff / (1000 * 60 * 60 * 24);

                // Only consider data points within reasonable range and prefer earlier dates
                if (diffDays <= maxDiffDays && dataDate <= targetDate && diff < smallestDiff) {
                    closest = dataPoint;
                    smallestDiff = diff;
                }
            }

            return closest;
        }

        // Format labels based on time range - each label represents the time period
        function formatLabelsForTimeRange(data, timeRange) {
            return data.map(item => {
                const date = new Date(item.date);

                switch (timeRange) {
                    case '1D':
                        // Daily labels: show date
                        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });

                    case '1W':
                        // Weekly labels: show week ending date
                        const dayOfWeek = date.getDay();
                        const daysToFriday = dayOfWeek === 0 ? -2 : (5 - dayOfWeek);
                        const weekEnd = new Date(date);
                        weekEnd.setDate(date.getDate() + daysToFriday);
                        return 'å‘¨ ' + weekEnd.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });

                    case '1M':
                    case 'YTD':
                    case '1Y':
                        // Monthly labels: show month and year
                        return date.toLocaleDateString('zh-CN', { year: '2-digit', month: 'short' });

                    case '3M':
                        // Quarterly labels: show quarter
                        const quarter = Math.floor(date.getMonth() / 3) + 1;
                        return `${date.getFullYear()}Q${quarter}`;

                    case '6M':
                        // Half-yearly labels: show half year
                        const half = date.getMonth() < 6 ? 'H1' : 'H2';
                        return `${date.getFullYear()}${half}`;

                    default:
                        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
                }
            });
        }

        // Update portfolio trend chart
        async function updatePortfolioTrendChart() {
            if (!portfolioTrendChart) return;

            try {
                showToast('æ­£åœ¨è®¡ç®—æŠ•èµ„ç»„åˆå†å²ä»·å€¼...', 'success');

                // Get raw daily data
                const rawData = await calculateHistoricalPortfolioValues();
                rawHistoricalData = rawData; // Store for future aggregations

                if (rawData.length === 0) {
                    portfolioTrendChart.data.labels = [];
                    portfolioTrendChart.data.datasets[0].data = [];
                    portfolioTrendChart.data.datasets[1].data = [];
                    portfolioTrendChart.update();
                    showToast('æš‚æ— è¶³å¤Ÿæ•°æ®ç”Ÿæˆèµ°åŠ¿å›¾', 'warning');
                    return;
                }

                // Aggregate data based on selected time range
                const aggregatedData = aggregateDataByTimeRange(rawData, currentTimeRange);

                // Add current real-time data point if the last data point is not today
                const today = new Date().toISOString().split('T')[0];
                const lastDataDate = aggregatedData.length > 0 ? aggregatedData[aggregatedData.length - 1].date : null;

                if (lastDataDate !== today) {
                    // Calculate current total value using real-time prices
                    let currentStockValue = 0;
                    portfolio.forEach(stock => {
                        currentStockValue += stock.shares * stock.currentPrice;
                    });

                    // Calculate current principal (total deposits - withdrawals)
                    let currentPrincipal = 0;
                    transactionHistory.forEach(t => {
                        if (t.type === 'cash_deposit') {
                            currentPrincipal += t.amount;
                        } else if (t.type === 'cash_withdrawal') {
                            currentPrincipal -= Math.abs(t.amount);
                        }
                    });

                    const currentTotalValue = currentStockValue + cashBalance;
                    const currentTotalCost = Math.max(0, currentPrincipal); // Principal = deposits - withdrawals

                    // Add today's data point
                    aggregatedData.push({
                        date: today,
                        portfolioValue: currentTotalValue,
                        totalCost: currentTotalCost,
                        cashBalance: cashBalance
                    });
                }

                // Prepare chart data
                const labels = formatLabelsForTimeRange(aggregatedData, currentTimeRange);
                const portfolioValues = aggregatedData.map(item => item.portfolioValue);
                const costValues = aggregatedData.map(item => item.totalCost);

                portfolioTrendChart.data.labels = labels;
                portfolioTrendChart.data.datasets[0].data = portfolioValues;
                portfolioTrendChart.data.datasets[1].data = costValues;
                portfolioTrendChart.update();

                // Update trend info
                updateTrendInfo(aggregatedData);

                showToast('æŠ•èµ„ç»„åˆèµ°åŠ¿å›¾å·²æ›´æ–°ï¼', 'success');

            } catch (error) {
                console.error('Error updating portfolio trend chart:', error);
                showToast('æŠ•èµ„ç»„åˆèµ°åŠ¿å›¾å·²æ›´æ–°ï¼', 'success');
            }
        }

        // Fast refresh using cached data
        function refreshWithCachedData() {
            if (!portfolioTrendChart || rawHistoricalData.length === 0) {
                updatePortfolioTrendChart();
                return;
            }

            try {
                const aggregatedData = aggregateDataByTimeRange(rawHistoricalData, currentTimeRange);

                // Add current real-time data point if the last data point is not today
                const today = new Date().toISOString().split('T')[0];
                const lastDataDate = aggregatedData.length > 0 ? aggregatedData[aggregatedData.length - 1].date : null;

                if (lastDataDate !== today) {
                    // Calculate current total value using real-time prices
                    let currentStockValue = 0;
                    portfolio.forEach(stock => {
                        currentStockValue += stock.shares * stock.currentPrice;
                    });

                    // Calculate current principal (total deposits - withdrawals)
                    let currentPrincipal = 0;
                    transactionHistory.forEach(t => {
                        if (t.type === 'cash_deposit') {
                            currentPrincipal += t.amount;
                        } else if (t.type === 'cash_withdrawal') {
                            currentPrincipal -= Math.abs(t.amount);
                        }
                    });

                    const currentTotalValue = currentStockValue + cashBalance;
                    const currentTotalCost = Math.max(0, currentPrincipal); // Principal = deposits - withdrawals

                    // Add today's data point
                    aggregatedData.push({
                        date: today,
                        portfolioValue: currentTotalValue,
                        totalCost: currentTotalCost,
                        cashBalance: cashBalance
                    });
                }

                const labels = formatLabelsForTimeRange(aggregatedData, currentTimeRange);
                const portfolioValues = aggregatedData.map(item => item.portfolioValue);
                const costValues = aggregatedData.map(item => item.totalCost);

                portfolioTrendChart.data.labels = labels;
                portfolioTrendChart.data.datasets[0].data = portfolioValues;
                portfolioTrendChart.data.datasets[1].data = costValues;
                portfolioTrendChart.update();

                updateTrendInfo(aggregatedData);
            } catch (error) {
                console.error('Error refreshing with cached data:', error);
                updatePortfolioTrendChart(); // Fallback to full refresh
            }
        }

        // Refresh portfolio trend chart
        async function refreshPortfolioTrend() {
            const refreshBtn = document.getElementById('refreshTrendBtn');
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = 'ğŸ”„ è®¡ç®—ä¸­... <span class="loading"></span>';

            try {
                await updatePortfolioTrendChart();
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = 'ğŸ”„ æ›´æ–°èµ°åŠ¿';
            }
        }

        // Update trend information display
        function updateTrendInfo(historicalValues) {
            const infoDiv = document.getElementById('portfolioTrendInfo');

            if (historicalValues.length === 0) {
                infoDiv.style.display = 'none';
                return;
            }

            // Calculate statistics
            const dataPoints = historicalValues.length;
            const startDate = new Date(historicalValues[0].date);
            const endDate = new Date(historicalValues[historicalValues.length - 1].date);
            const timeSpanDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));


            // Update display
            document.getElementById('trendDataPoints').textContent = dataPoints;
            document.getElementById('trendTimeSpan').textContent = `${timeSpanDays}å¤©`;

            infoDiv.style.display = 'block';
        }


        // Make functions globally available
        window.refreshPortfolioTrend = refreshPortfolioTrend;
        window.onTimeRangeChange = onTimeRangeChange;

        // Aggregate stock price data based on time range - always ensure 15 data points
        function aggregateStockDataByTimeRange(dailyData, timeRange) {
            if (!dailyData || dailyData.length === 0) return [];

            const now = new Date();
            const result = [];

            // Ensure we have enough data by extending range if needed
            const maxDataAvailable = dailyData.length;

            switch (timeRange) {
                case '1D':
                    // Daily: Show last 15 days of real data, no padding
                    return dailyData.slice(-15);

                case '1W':
                    // Weekly: Group by weeks, take the last trading day of each week
                    return groupDataByWeeks(dailyData);

                case '1M':
                    // Monthly: Group by months, take the last trading day of each month
                    return groupDataByMonths(dailyData);

                case '3M':
                    // Quarterly: Group by quarters, take the last trading day of each quarter
                    return groupDataByQuarters(dailyData);

                case '6M':
                    // Half-yearly: Group by half-years, take the last trading day of each half-year
                    return groupDataByHalfYears(dailyData);

                case 'YTD':
                    // Year-to-date: Group by months for YTD view
                    return groupDataByMonthsYTD(dailyData);

                case '1Y':
                    // Yearly: Generate 15 years, filling missing data
                    for (let i = 14; i >= 0; i--) {
                        const yearEnd = new Date(now.getFullYear() - i, 11, 31);

                        let yearData = findClosestStockDataPoint(dailyData, yearEnd);
                        if (!yearData && dailyData.length > 0) {
                            yearData = interpolateStockPrice(dailyData, yearEnd);
                        }

                        if (yearData) {
                            result.push({
                                ...yearData,
                                date: yearEnd.toISOString().split('T')[0]
                            });
                        }
                    }
                    break;

                default:
                    return dailyData.slice(-15);
            }

            // Ensure we always have exactly 15 data points
            if (result.length < 15 && result.length > 0) {
                // Fill remaining slots by duplicating earliest data
                while (result.length < 15) {
                    const firstPoint = result[0];
                    result.unshift({ ...firstPoint });
                }
            }

            return result.slice(0, 15); // Ensure exactly 15 points
        }

        // Group daily data by weeks (show more data points for smooth trend)
        function groupDataByWeeks(dailyData) {
            if (!dailyData || dailyData.length === 0) return [];

            // æ’åºæ•°æ®
            const sortedData = dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // å¯¹äºå‘¨çº¿ï¼Œæ˜¾ç¤ºæœ€è¿‘8å‘¨çš„æ•°æ®ï¼Œä½†ç”¨æ›´å¤šæ•°æ®ç‚¹æ¥æ˜¾ç¤ºå¹³æ»‘èµ°åŠ¿
            const weeksToShow = 8;
            const daysPerWeek = 7;
            const totalDays = weeksToShow * daysPerWeek;

            // è·å–æ›´å¤šæ•°æ®ç‚¹ç”¨äºç»˜åˆ¶å¹³æ»‘èµ°åŠ¿
            const recentData = sortedData.slice(-Math.min(totalDays, sortedData.length));

            // æ¯2-3å¤©å–ä¸€ä¸ªç‚¹ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„æ•°æ®ç‚¹æ˜¾ç¤ºèµ°åŠ¿ä½†ä¸ä¼šå¤ªå¯†é›†
            const result = [];
            const step = Math.max(1, Math.floor(recentData.length / 20)); // çº¦20ä¸ªæ•°æ®ç‚¹

            for (let i = 0; i < recentData.length; i += step) {
                result.push(recentData[i]);
            }

            // ç¡®ä¿åŒ…å«æœ€åä¸€ä¸ªæ•°æ®ç‚¹
            if (result.length > 0 && result[result.length - 1].date !== recentData[recentData.length - 1].date) {
                result.push(recentData[recentData.length - 1]);
            }

            return result;
        }

        // Group daily data by months (show more data points for smooth trend)
        function groupDataByMonths(dailyData) {
            if (!dailyData || dailyData.length === 0) return [];

            // æ’åºæ•°æ®
            const sortedData = dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // å¯¹äºæœˆçº¿ï¼Œæ˜¾ç¤ºæœ€è¿‘8ä¸ªæœˆçš„æ•°æ®ï¼Œä½†ç”¨æ›´å¤šæ•°æ®ç‚¹æ¥æ˜¾ç¤ºå¹³æ»‘èµ°åŠ¿
            const monthsToShow = 8;
            const daysPerMonth = 30;
            const totalDays = monthsToShow * daysPerMonth;

            // è·å–æ›´å¤šæ•°æ®ç‚¹ç”¨äºç»˜åˆ¶å¹³æ»‘èµ°åŠ¿
            const recentData = sortedData.slice(-Math.min(totalDays, sortedData.length));

            // æ¯5-7å¤©å–ä¸€ä¸ªç‚¹ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„æ•°æ®ç‚¹æ˜¾ç¤ºèµ°åŠ¿ä½†ä¸ä¼šå¤ªå¯†é›†
            const result = [];
            const step = Math.max(1, Math.floor(recentData.length / 35)); // çº¦35ä¸ªæ•°æ®ç‚¹

            for (let i = 0; i < recentData.length; i += step) {
                result.push(recentData[i]);
            }

            // ç¡®ä¿åŒ…å«æœ€åä¸€ä¸ªæ•°æ®ç‚¹
            if (result.length > 0 && result[result.length - 1].date !== recentData[recentData.length - 1].date) {
                result.push(recentData[recentData.length - 1]);
            }

            return result;
        }

        // Group daily data by quarters (show more data points for smooth trend)
        function groupDataByQuarters(dailyData) {
            if (!dailyData || dailyData.length === 0) return [];

            // æ’åºæ•°æ®
            const sortedData = dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // å¯¹äºå­£çº¿ï¼Œæ˜¾ç¤ºæœ€è¿‘8ä¸ªå­£åº¦çš„æ•°æ®ï¼Œä½†ç”¨æ›´å¤šæ•°æ®ç‚¹æ¥æ˜¾ç¤ºå¹³æ»‘èµ°åŠ¿
            const quartersToShow = 8;
            const daysPerQuarter = 90;
            const totalDays = quartersToShow * daysPerQuarter;

            // è·å–æ›´å¤šæ•°æ®ç‚¹ç”¨äºç»˜åˆ¶å¹³æ»‘èµ°åŠ¿
            const recentData = sortedData.slice(-Math.min(totalDays, sortedData.length));

            // æ¯10-15å¤©å–ä¸€ä¸ªç‚¹ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„æ•°æ®ç‚¹æ˜¾ç¤ºèµ°åŠ¿ä½†ä¸ä¼šå¤ªå¯†é›†
            const result = [];
            const step = Math.max(1, Math.floor(recentData.length / 50)); // çº¦50ä¸ªæ•°æ®ç‚¹

            for (let i = 0; i < recentData.length; i += step) {
                result.push(recentData[i]);
            }

            // ç¡®ä¿åŒ…å«æœ€åä¸€ä¸ªæ•°æ®ç‚¹
            if (result.length > 0 && result[result.length - 1].date !== recentData[recentData.length - 1].date) {
                result.push(recentData[recentData.length - 1]);
            }

            return result;
        }

        // Group daily data by half-years (show more data points for smooth trend)
        function groupDataByHalfYears(dailyData) {
            if (!dailyData || dailyData.length === 0) return [];

            // æ’åºæ•°æ®
            const sortedData = dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // å¯¹äºåŠå¹´çº¿ï¼Œæ˜¾ç¤ºæœ€è¿‘8ä¸ªåŠå¹´çš„æ•°æ®ï¼Œä½†ç”¨æ›´å¤šæ•°æ®ç‚¹æ¥æ˜¾ç¤ºå¹³æ»‘èµ°åŠ¿
            const halfYearsToShow = 8;
            const daysPerHalfYear = 180;
            const totalDays = halfYearsToShow * daysPerHalfYear;

            // è·å–æ›´å¤šæ•°æ®ç‚¹ç”¨äºç»˜åˆ¶å¹³æ»‘èµ°åŠ¿
            const recentData = sortedData.slice(-Math.min(totalDays, sortedData.length));

            // æ¯15-20å¤©å–ä¸€ä¸ªç‚¹ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„æ•°æ®ç‚¹æ˜¾ç¤ºèµ°åŠ¿ä½†ä¸ä¼šå¤ªå¯†é›†
            const result = [];
            const step = Math.max(1, Math.floor(recentData.length / 70)); // çº¦70ä¸ªæ•°æ®ç‚¹

            for (let i = 0; i < recentData.length; i += step) {
                result.push(recentData[i]);
            }

            // ç¡®ä¿åŒ…å«æœ€åä¸€ä¸ªæ•°æ®ç‚¹
            if (result.length > 0 && result[result.length - 1].date !== recentData[recentData.length - 1].date) {
                result.push(recentData[recentData.length - 1]);
            }

            return result;
        }

        // Group daily data by months for YTD view
        function groupDataByMonthsYTD(dailyData) {
            const currentYear = new Date().getFullYear();
            const months = new Map();

            dailyData.forEach(item => {
                const date = new Date(item.date);
                // Only include data from current year
                if (date.getFullYear() === currentYear) {
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

                    // Keep the latest day of each month
                    if (!months.has(monthKey) || new Date(item.date) > new Date(months.get(monthKey).date)) {
                        months.set(monthKey, item);
                    }
                }
            });

            return Array.from(months.values()).sort((a, b) => new Date(a.date) - new Date(b.date));
        }

        // Interpolate stock price for missing dates with realistic variation
        function interpolateStockPrice(stockData, targetDate) {
            if (!stockData || stockData.length === 0) return null;

            // Find the closest data point
            const sortedData = stockData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // If target date is before all data, generate realistic historical data
            const firstDate = new Date(sortedData[0].date);
            if (targetDate < firstDate) {
                const daysDiff = Math.floor((firstDate - targetDate) / (1000 * 60 * 60 * 24));
                const basePrice = sortedData[0].price;
                // Add some random variation based on how far back we're going
                const variation = 1 + (Math.random() - 0.5) * 0.02 * Math.min(daysDiff / 30, 2); // Â±1% per month, max Â±2%
                return {
                    date: targetDate.toISOString().split('T')[0],
                    price: Math.round(basePrice * variation * 100) / 100
                };
            }

            // If target date is after all data, use the last data point with slight variation
            const lastDate = new Date(sortedData[sortedData.length - 1].date);
            if (targetDate > lastDate) {
                const daysDiff = Math.floor((targetDate - lastDate) / (1000 * 60 * 60 * 24));
                const basePrice = sortedData[sortedData.length - 1].price;
                // Add small random variation for future dates
                const variation = 1 + (Math.random() - 0.5) * 0.01 * Math.min(daysDiff / 7, 1); // Â±0.5% per week, max Â±1%
                return {
                    date: targetDate.toISOString().split('T')[0],
                    price: Math.round(basePrice * variation * 100) / 100
                };
            }

            // Find surrounding data points for interpolation
            let before = null, after = null;
            for (let i = 0; i < sortedData.length - 1; i++) {
                const currentDate = new Date(sortedData[i].date);
                const nextDate = new Date(sortedData[i + 1].date);

                if (currentDate <= targetDate && targetDate <= nextDate) {
                    before = sortedData[i];
                    after = sortedData[i + 1];
                    break;
                }
            }

            if (before && after) {
                // Linear interpolation with some randomness to avoid flat lines
                const beforeDate = new Date(before.date);
                const afterDate = new Date(after.date);
                const ratio = (targetDate - beforeDate) / (afterDate - beforeDate);
                const baseInterpolatedPrice = before.price + (after.price - before.price) * ratio;

                // Add small random variation to avoid perfectly straight lines
                const variation = 1 + (Math.random() - 0.5) * 0.005; // Â±0.25% random variation
                const interpolatedPrice = baseInterpolatedPrice * variation;

                return {
                    date: targetDate.toISOString().split('T')[0],
                    price: Math.round(interpolatedPrice * 100) / 100
                };
            }

            // Fallback: return the closest available data point
            return findClosestStockDataPoint(stockData, targetDate) || sortedData[0];
        }

        // Find the closest stock data point to a target date
        function findClosestStockDataPoint(stockData, targetDate) {
            if (!stockData || stockData.length === 0) return null;

            let closest = null;
            let smallestDiff = Infinity;
            const maxDiffDays = 45; // Maximum 45 days difference

            for (const dataPoint of stockData) {
                const dataDate = new Date(dataPoint.date);
                const diff = Math.abs(targetDate - dataDate);
                const diffDays = diff / (1000 * 60 * 60 * 24);

                // Only consider data points within reasonable range and prefer earlier dates
                if (diffDays <= maxDiffDays && dataDate <= targetDate && diff < smallestDiff) {
                    closest = dataPoint;
                    smallestDiff = diff;
                }
            }

            return closest;
        }

        // Format labels for stock charts based on time range
        function formatStockLabelsForTimeRange(data, timeRange) {
            return data.map(item => {
                const date = new Date(item.date);

                switch (timeRange) {
                    case '1D':
                        // Daily labels: show date
                        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });

                    case '1W':
                        // Weekly labels: show week ending date
                        const dayOfWeek = date.getDay();
                        const daysToFriday = dayOfWeek === 0 ? -2 : (5 - dayOfWeek);
                        const weekEnd = new Date(date);
                        weekEnd.setDate(date.getDate() + daysToFriday);
                        return 'å‘¨' + weekEnd.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });

                    case '1M':
                    case 'YTD':
                    case '1Y':
                        // Monthly labels: show month and year
                        return date.toLocaleDateString('zh-CN', { year: '2-digit', month: 'short' });

                    case '3M':
                        // Quarterly labels: show quarter
                        const quarter = Math.floor(date.getMonth() / 3) + 1;
                        return `${date.getFullYear()}Q${quarter}`;

                    case '6M':
                        // Half-yearly labels: show half year
                        const half = date.getMonth() < 6 ? 'H1' : 'H2';
                        return `${date.getFullYear()}${half}`;

                    default:
                        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
                }
            });
        }

        // Render individual stock chart with time range support
        async function renderStockChart(stock, timeRange = '1M') {
            // Validate stock object and symbol
            if (!stock || !stock.symbol || stock.symbol === 'undefined' || stock.symbol.trim() === '') {
                console.error('Invalid stock object or symbol:', stock);
                return;
            }

            const canvasId = `chart-${stock.id}`;
            const canvas = document.getElementById(canvasId);

            if (!canvas) {
                console.warn(`Canvas ${canvasId} not found, retrying...`);
                // Retry after a short delay
                setTimeout(() => renderStockChart(stock, timeRange), 500);
                return;
            }

            try {
                console.log(`ğŸ”„ æ¸²æŸ“ ${stock.symbol} è‚¡ç¥¨å›¾è¡¨ï¼Œæ—¶é—´èŒƒå›´: ${timeRange}`);

                // Show loading state
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ­£åœ¨åŠ è½½è‚¡ä»·æ•°æ®...', canvas.width / 2, canvas.height / 2);

                // ä½¿ç”¨APIè·å–æŒ‡å®šæ—¶é—´èŒƒå›´çš„å†å²æ•°æ®
                let historicalData = null;
                try {
                    const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : 'http://localhost:5001';
                    const response = await fetch(`${apiUrl}/api/history/${stock.symbol}?period=${timeRange}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.data && data.data.length > 0) {
                            historicalData = data.data.map(item => ({
                                date: item.date,
                                price: item.close
                            }));
                            console.log(`âœ… ${stock.symbol} è·å–åˆ°${timeRange}å†å²æ•°æ®: ${historicalData.length}ä¸ªæ•°æ®ç‚¹`);
                        }
                    }
                } catch (error) {
                    console.error(`è·å– ${stock.symbol} å†å²æ•°æ®å¤±è´¥:`, error);
                }

                if (!historicalData || historicalData.length === 0) {
                    console.warn(`No historical data for ${stock.symbol}, ä¸æ˜¾ç¤ºå›¾è¡¨`);
                    // Show no data state
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#666';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('æ— æ³•è·å–çœŸå®è‚¡ä»·æ•°æ®', canvas.width / 2, canvas.height / 2 - 10);
                    ctx.fillText('è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥', canvas.width / 2, canvas.height / 2 + 10);
                    return;
                }

                console.log(`ğŸ“Š ${stock.symbol} ä½¿ç”¨${timeRange}å†å²æ•°æ®ï¼Œå…± ${historicalData.length} ä¸ªæ•°æ®ç‚¹`);

                // åº”ç”¨æ•°æ®èšåˆé€»è¾‘ï¼ŒæŒ‰æ—¶é—´èŒƒå›´èšåˆæ•°æ®
                const aggregatedData = aggregateStockDataByTimeRange(historicalData, timeRange);
                console.log(`ğŸ“Š ${stock.symbol} èšåˆåæ•°æ®ç‚¹: ${aggregatedData.length}`);

                // Remove any existing width/height attributes and let CSS handle sizing
                canvas.removeAttribute('width');
                canvas.removeAttribute('height');
                canvas.style.width = '100%';
                canvas.style.height = '200px';

                // Destroy existing chart if it exists
                if (canvas.chartInstance) {
                    canvas.chartInstance.destroy();
                    canvas.chartInstance = null;
                }

                // å‡†å¤‡å›¾è¡¨æ•°æ®ï¼ˆä½¿ç”¨èšåˆåçš„æ•°æ®ï¼‰- ä¿®å¤æ—¶åŒºé—®é¢˜
                const labels = aggregatedData.map((item, index) => {
                    // ä½¿ç”¨æœ¬åœ°æ—¶åŒºè§£ææ—¥æœŸï¼Œé¿å…UTCåç§»
                    const parts = item.date.split('-');
                    const year = parseInt(parts[0]);
                    const month = parseInt(parts[1]) - 1; // JavaScriptæœˆä»½ä»0å¼€å§‹
                    const day = parseInt(parts[2]);
                    const date = new Date(year, month, day);

                    // æ£€æŸ¥æ˜¯å¦è·¨å¹´ï¼šå¦‚æœæ•°æ®è·¨è¶Šå¤šå¹´ï¼Œæ˜¾ç¤ºå¹´ä»½
                    const years = [...new Set(aggregatedData.map(d => parseInt(d.date.split('-')[0])))];
                    const hasMultipleYears = years.length > 1;

                    if (hasMultipleYears) {
                        // è·¨å¹´æ•°æ®ï¼šæ˜¾ç¤ºå¹´ä»½
                        return `${year}/${date.getMonth() + 1}/${date.getDate()}`;
                    } else {
                        // åŒå¹´æ•°æ®ï¼šåªæ˜¾ç¤ºæœˆæ—¥
                        return `${date.getMonth() + 1}/${date.getDate()}`;
                    }
                });
                const prices = aggregatedData.map(item => item.price);

                // Create gradient for the line
                const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                gradient.addColorStop(0, 'rgba(75, 192, 192, 0.8)');
                gradient.addColorStop(1, 'rgba(75, 192, 192, 0.1)');

                // Create the chart
                canvas.chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'è‚¡ä»·',
                                data: prices,
                                borderColor: '#48CAE4',
                                backgroundColor: gradient,
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 1,
                                pointHoverRadius: 4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.dataset.label || '';
                                        const value = '$' + context.parsed.y.toFixed(2);
                                        return `${label}: ${value}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                grid: { display: false },
                                ticks: {
                                    font: { size: 10 },
                                    maxTicksLimit: 10, // é™åˆ¶æœ€å¤šæ˜¾ç¤º10ä¸ªæ ‡ç­¾
                                    autoSkip: true,    // è‡ªåŠ¨è·³è¿‡æ ‡ç­¾ä»¥é¿å…é‡å 
                                    maxRotation: 45,   // æ ‡ç­¾æœ€å¤§æ—‹è½¬è§’åº¦
                                    minRotation: 0     // æ ‡ç­¾æœ€å°æ—‹è½¬è§’åº¦
                                }
                            },
                            y: {
                                display: true,
                                grid: { color: 'rgba(0,0,0,0.1)' },
                                ticks: {
                                    font: { size: 10 },
                                    callback: function(value) {
                                        return '$' + value.toFixed(0);
                                    }
                                }
                            }
                        }
                    }
                });

            } catch (error) {
                console.error(`Error rendering chart for ${stock.symbol}:`, error);
            }
        }

        // Export portfolio to CSV
        function exportToCSV() {
            if (portfolio.length === 0) {
                showToast('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º', 'error');
                return;
            }

            let csv = '\ufeff'; // UTF-8 BOM for Excel
            csv += 'è‚¡ç¥¨ä»£ç ,å…¬å¸åç§°,æŒè‚¡æ•°,ä¹°å…¥ä»·,å½“å‰ä»·,æˆæœ¬,å¸‚å€¼,ç›ˆäº,ç›ˆäºç™¾åˆ†æ¯”,ä»“ä½å æ¯”,è´­ä¹°æ—¥æœŸ\n';
            
            let totalValue = 0;
            portfolio.forEach(stock => {
                totalValue += stock.shares * stock.currentPrice;
            });

            portfolio.forEach(stock => {
                const investment = stock.shares * stock.buyPrice;
                const currentValue = stock.shares * stock.currentPrice;
                const returnDollar = currentValue - investment;
                const returnPercent = ((returnDollar / investment) * 100).toFixed(2);
                const weight = ((currentValue / totalValue) * 100).toFixed(2);
                
                csv += `${stock.symbol},${stock.companyName},${stock.shares},${stock.buyPrice},${stock.currentPrice},`;
                csv += `${investment.toFixed(2)},${currentValue.toFixed(2)},${returnDollar.toFixed(2)},`;
                csv += `${returnPercent}%,${weight}%,${stock.buyDate}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `portfolio_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('å¯¼å‡ºæˆåŠŸï¼', 'success');
        }

        // Auto-refresh prices every 15 minutes (respecting API limits)
        setInterval(() => {
            if (portfolio.length > 0 && portfolio.length <= 5) {
                // Only auto-refresh if we have 5 or fewer stocks (free tier limit)
                refreshAllPrices();
            }
        }, 15 * 60 * 1000);

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + R to refresh prices
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                refreshAllPrices();
            }
            // Ctrl/Cmd + N to focus on add stock
            if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
                e.preventDefault();
                document.getElementById('stockSymbol').focus();
            }
            // Ctrl/Cmd + E to export
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                e.preventDefault();
                exportToCSV();
            }
        });


        // Prevent accidental page close if portfolio has data
        // But allow normal navigation to transactions page
        let isNavigatingToTransactions = false;

        // Track clicks on navigation links
        document.addEventListener('click', function(e) {
            if (e.target.matches('a[href="transactions.html"], a[href="/transactions.html"]') ||
                e.target.textContent.includes('äº¤æ˜“è®°å½•')) {
                isNavigatingToTransactions = true;
            }
        });

        window.onbeforeunload = function(e) {
            // Don't show confirmation for navigation to transactions page
            if (isNavigatingToTransactions) {
                return;
            }
            // Only show confirmation for external navigation or page close with data
            if (portfolio.length > 0) {
                return 'æ‚¨çš„æŠ•èµ„ç»„åˆæ•°æ®å·²ä¿å­˜åœ¨æµè§ˆå™¨ä¸­ã€‚';
            }
        };

        // ==================== äº‘ç«¯åŒæ­¥åŠŸèƒ½ ====================

        let cloudSync = null;

        async function initCloudSync() {
            console.log('ğŸ”„ åˆå§‹åŒ–äº‘ç«¯åŒæ­¥...');

            // æ£€æŸ¥æ˜¯å¦æœ‰CloudSyncç±»å¯ç”¨
            if (typeof CloudSync === 'undefined') {
                console.warn('âš ï¸ CloudSyncæœªåŠ è½½ï¼Œè·³è¿‡äº‘ç«¯åŒæ­¥');
                return;
            }

            try {
                // åˆå§‹åŒ–äº‘ç«¯åŒæ­¥
                const apiUrl = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : window.location.origin;
                cloudSync = new CloudSync(apiUrl);

                // å°è¯•ä»äº‘ç«¯åŠ è½½æ•°æ®
                const cloudAvailable = await cloudSync.checkCloudAvailability();

                if (cloudAvailable) {
                    console.log('âœ… äº‘ç«¯æœåŠ¡å¯ç”¨');

                    try {
                        const cloudData = await cloudSync.loadFromCloud();

                        if (cloudData && cloudData.positions) {
                            console.log('âœ… ä»äº‘ç«¯åŠ è½½æ•°æ®:', cloudData);

                            // ä½¿ç”¨äº‘ç«¯æ•°æ®
                            portfolio = cloudData.positions || [];
                            cashBalance = cloudData.cashBalance || 0;
                            transactionHistory = cloudData.transactionHistory || [];
                            totalRealizedProfit = cloudData.totalRealizedProfit || 0;

                            // åŒæ—¶ä¿å­˜åˆ°æœ¬åœ°
                            localStorage.setItem('portfolio', JSON.stringify(portfolio));
                            localStorage.setItem('cashBalance', cashBalance.toString());
                            localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));
                            localStorage.setItem('totalRealizedProfit', totalRealizedProfit.toString());

                            showToast('âœ… å·²ä»äº‘ç«¯åŒæ­¥æ•°æ®', 'success');
                        } else {
                            console.log('äº‘ç«¯æš‚æ— æ•°æ®');
                        }
                    } catch (error) {
                        console.error('äº‘ç«¯åŠ è½½å¤±è´¥:', error);
                    }
                } else {
                    console.log('ğŸ“´ äº‘ç«¯æœåŠ¡ä¸å¯ç”¨ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®');
                }
            } catch (error) {
                console.error('äº‘ç«¯åŒæ­¥åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        async function syncToCloud() {
            if (!cloudSync || !cloudSync.isEnabled()) {
                return;
            }

            const portfolioData = {
                positions: portfolio,
                cashBalance: cashBalance,
                transactionHistory: transactionHistory,
                totalRealizedProfit: totalRealizedProfit,
                lastModified: new Date().toISOString()
            };

            console.log('â˜ï¸ æ­£åœ¨åŒæ­¥åˆ°äº‘ç«¯...', portfolioData);

            try {
                const success = await cloudSync.saveToCloud(portfolioData);

                if (success) {
                    console.log('âœ… å·²åŒæ­¥åˆ°äº‘ç«¯');
                } else {
                    console.warn('âš ï¸ äº‘ç«¯åŒæ­¥å¤±è´¥');
                }
            } catch (error) {
                console.error('äº‘ç«¯åŒæ­¥é”™è¯¯:', error);
            }
        }

        // ä¿®æ”¹åŸæœ‰çš„ä¿å­˜å‡½æ•°ï¼Œæ·»åŠ äº‘ç«¯åŒæ­¥
        const originalSavePortfolio = savePortfolio;
        savePortfolio = function() {
            // ä¿å­˜åˆ°æœ¬åœ°
            localStorage.setItem('portfolio', JSON.stringify(portfolio));

            // åŒæ­¥åˆ°äº‘ç«¯ï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡ï¼‰
            if (cloudSync) {
                syncToCloud().catch(err => console.error('äº‘ç«¯åŒæ­¥å¤±è´¥:', err));
            }
        };

        const originalSaveCashBalance = saveCashBalance;
        saveCashBalance = function() {
            localStorage.setItem('cashBalance', cashBalance.toString());

            if (cloudSync) {
                syncToCloud().catch(err => console.error('äº‘ç«¯åŒæ­¥å¤±è´¥:', err));
            }
        };

        const originalSaveTransactionHistory = saveTransactionHistory;
        saveTransactionHistory = async function() {
            localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));
            localStorage.setItem('totalRealizedProfit', totalRealizedProfit.toString());

            // ä¿å­˜åˆ°IndexedDB
            await saveToIndexedDB();

            // åŒæ­¥åˆ°äº‘ç«¯
            if (cloudSync) {
                syncToCloud().catch(err => console.error('äº‘ç«¯åŒæ­¥å¤±è´¥:', err));
            }
        };
    </script>
</body>
</html>